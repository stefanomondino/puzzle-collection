<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#6C5CE7">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Puzzle">
<link rel="manifest" href="manifest.json">
<link rel="icon" href="icon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="icon.svg">
<title>Crowns - Puzzle Game</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

  :root {
    --bg: #faf8f5;
    --card: #ffffff;
    --primary: #6C5CE7;
    --primary-light: #e8e4fd;
    --text: #2d2d2d;
    --text-muted: #777777;
    --success: #00b894;
    --cell-size: 60px;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    -webkit-user-select: none;
  }

  header {
    width: 100%;
    max-width: 500px;
    padding: 16px 20px 8px;
    text-align: center;
    position: relative;
  }

  header h1 {
    font-size: 28px;
    font-weight: 700;
    letter-spacing: 2px;
    color: var(--primary);
    text-transform: uppercase;
  }

  header p {
    font-size: 13px;
    color: var(--text-muted);
    margin-top: 2px;
  }

  .toolbar {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 8px 20px;
    width: 100%;
    max-width: 500px;
  }

  .timer {
    font-size: 22px;
    font-weight: 600;
    font-variant-numeric: tabular-nums;
    color: var(--text);
    min-width: 70px;
    text-align: center;
  }

  .btn {
    border: none;
    border-radius: 20px;
    padding: 8px 18px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }

  .btn:active { transform: scale(0.95); }

  .btn-outline {
    background: transparent;
    color: var(--primary);
    border: 2px solid var(--primary);
  }

  .btn-outline:hover { background: var(--primary-light); }

  .btn-primary {
    background: var(--primary);
    color: #fff;
  }

  .btn-primary:hover { background: #5a4bd6; }

  .diff-selector {
    display: flex;
    gap: 8px;
    padding: 4px 20px 12px;
    justify-content: center;
    flex-wrap: wrap;
    max-width: 500px;
  }

  .diff-btn {
    border-radius: 20px;
    border: 2px solid #d9d9d9;
    background: var(--card);
    padding: 6px 16px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--text);
  }

  .diff-btn.active {
    background: var(--primary);
    color: #fff;
    border-color: var(--primary);
  }

  .diff-btn:hover:not(.active) { background: var(--primary-light); }

  .stats {
    font-size: 12px;
    color: var(--text-muted);
    text-align: center;
    padding: 0 20px 8px;
  }

  .board-container {
    background: var(--card);
    border-radius: 16px;
    padding: 16px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.08);
    position: relative;
    touch-action: none;
  }

  .board {
    display: grid;
    gap: 0;
    position: relative;
    border-radius: 8px;
    overflow: hidden;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    cursor: pointer;
    transition: filter 0.15s;
    border: 1px solid rgba(0,0,0,0.06);
  }

  .cell:active { filter: brightness(0.92); }

  .cell.border-top { border-top: 3px solid #333; }
  .cell.border-right { border-right: 3px solid #333; }
  .cell.border-bottom { border-bottom: 3px solid #333; }
  .cell.border-left { border-left: 3px solid #333; }

  .queen {
    font-size: calc(var(--cell-size) * 0.5);
    line-height: 1;
    color: #191919;
    z-index: 2;
    animation: queenPop 0.2s ease;
  }

  @keyframes queenPop {
    from { transform: scale(0); }
    to { transform: scale(1); }
  }

  .cell.conflict .queen {
    color: #c62828;
  }

  .cell.conflict {
    box-shadow: inset 0 0 0 3px rgba(198,40,40,0.5);
  }

  .cell.x-mark::before {
    content: '✕';
    position: absolute;
    font-size: calc(var(--cell-size) * 0.3);
    color: rgba(0,0,0,0.4);
    z-index: 1;
  }

  .cell.x-auto::before {
    color: rgba(0,0,0,0.15);
    font-size: calc(var(--cell-size) * 0.22);
  }

  .message {
    margin-top: 16px;
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    text-align: center;
    opacity: 0;
    transition: opacity 0.3s;
  }

  .message.visible { opacity: 1; }
  .message.success { background: #e8f5e9; color: var(--success); }

  .overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }

  .overlay.visible { display: flex; }

  .modal {
    background: var(--card);
    border-radius: 20px;
    padding: 32px;
    max-width: 340px;
    width: 90%;
    text-align: center;
    animation: pop 0.3s ease;
  }

  @keyframes pop {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 { font-size: 24px; margin-bottom: 8px; color: var(--success); }
  .modal p { color: var(--text-muted); margin-bottom: 20px; }
  .modal .time { font-size: 36px; font-weight: 700; color: var(--text); margin: 8px 0; }

  .instructions {
    max-width: 500px;
    padding: 12px 20px;
    text-align: center;
    font-size: 13px;
    color: var(--text-muted);
    line-height: 1.5;
  }

  @media (max-width: 420px) {
    :root { --cell-size: 50px; }
  }

  @media (max-width: 350px) {
    :root { --cell-size: 44px; }
  }
</style>
</head>
<body>

<header>
  <a href="index.html" style="position:absolute;left:16px;top:16px;color:var(--primary);text-decoration:none;font-size:18px;font-weight:600;">← Menu</a>
  <h1>Crowns</h1>
  <p>Posiziona le corone sulla scacchiera</p>
</header>

<div class="toolbar">
  <button class="btn btn-outline" id="btnUndo">↩ Annulla</button>
  <div class="timer" id="timer">0:00</div>
  <button class="btn btn-outline" id="btnReset">⟳ Reset</button>
</div>

<div class="diff-selector" id="diffSelector">
  <button class="diff-btn active" data-size="5">5×5</button>
  <button class="diff-btn" data-size="6">6×6</button>
  <button class="diff-btn" data-size="7">7×7</button>
  <button class="diff-btn" data-size="8">8×8</button>
  <button class="diff-btn" data-size="9">9×9</button>
</div>

<p class="stats" id="stats"></p>

<div class="board-container" id="boardContainer">
  <div class="board" id="board"></div>
</div>

<div class="message" id="message"></div>

<p class="instructions">
  Posiziona esattamente una corona <strong>♛</strong> per ogni regione colorata.
  Le corone non possono trovarsi nella stessa riga, colonna, o in celle adiacenti (incluse le diagonali).<br>
  <strong>Tap</strong> o <strong>trascina</strong> per segnare/rimuovere le ✕ · <strong>Doppio tap</strong> per piazzare/rimuovere una corona.
</p>

<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="modalTitle">Completato!</h2>
    <div class="time" id="modalTime">0:00</div>
    <p id="modalMsg">Hai risolto il puzzle!</p>
    <button class="btn btn-primary" id="btnNext" style="margin-top:8px;">Nuovo puzzle →</button>
  </div>
</div>

<script>
// ─── Seeded PRNG (Mulberry32) ───────────────────────────────────
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function shuffleArray(arr, rng) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// ─── Region Colors ──────────────────────────────────────────────
const REGION_COLORS = [
  '#FFB3B3', '#FFD699', '#FFF2A8', '#B3E6B3', '#A8D4FF',
  '#D4B3FF', '#FFB3D9', '#A8E6E6', '#E6CCAA',
];

// ─── Random Partition Generator ─────────────────────────────────
function generateRandomPartition(n, rng) {
  const grid = Array.from({length: n}, () => new Array(n).fill(-1));
  const allCells = [];
  for (let r = 0; r < n; r++)
    for (let c = 0; c < n; c++)
      allCells.push([r, c]);
  shuffleArray(allCells, rng);

  const seedCells = allCells.slice(0, n);
  const frontiers = [];
  for (let i = 0; i < n; i++) {
    const [r, c] = seedCells[i];
    grid[r][c] = i;
    frontiers.push([[r, c]]);
  }

  function getN4(r, c) {
    const ns = [];
    if (r > 0) ns.push([r-1, c]);
    if (r < n-1) ns.push([r+1, c]);
    if (c > 0) ns.push([r, c-1]);
    if (c < n-1) ns.push([r, c+1]);
    return ns;
  }

  let unclaimed = n * n - n;
  let safety = n * n * 20;
  while (unclaimed > 0 && safety-- > 0) {
    for (let region = 0; region < n; region++) {
      if (frontiers[region].length === 0) continue;
      let claimed = false;
      let tries = frontiers[region].length;
      while (tries-- > 0 && !claimed) {
        const idx = Math.floor(rng() * frontiers[region].length);
        const [fr, fc] = frontiers[region][idx];
        const neighbors = getN4(fr, fc);
        shuffleArray(neighbors, rng);
        for (const [nr, nc] of neighbors) {
          if (grid[nr][nc] === -1) {
            grid[nr][nc] = region;
            frontiers[region].push([nr, nc]);
            unclaimed--;
            claimed = true;
            break;
          }
        }
        if (!claimed) frontiers[region].splice(idx, 1);
      }
    }
  }

  for (let r = 0; r < n; r++)
    for (let c = 0; c < n; c++)
      if (grid[r][c] === -1) return null;
  return grid;
}

// ─── Solution Finder & Counter ──────────────────────────────────
function countSolutions(n, regions, maxCount) {
  const queens = new Array(n).fill(-1);
  const usedCols = new Set();
  const usedRegions = new Set();
  let count = 0;

  function isAdjacentSafe(row, col) {
    for (let r = Math.max(0, row - 1); r < row; r++) {
      if (Math.abs(queens[r] - col) <= 1) return false;
    }
    return true;
  }

  function solve(row) {
    if (row === n) { count++; return count >= maxCount; }
    for (let col = 0; col < n; col++) {
      const region = regions[row][col];
      if (usedCols.has(col) || usedRegions.has(region)) continue;
      if (!isAdjacentSafe(row, col)) continue;
      queens[row] = col;
      usedCols.add(col);
      usedRegions.add(region);
      if (solve(row + 1)) return true;
      queens[row] = -1;
      usedCols.delete(col);
      usedRegions.delete(region);
    }
    return false;
  }

  solve(0);
  return count;
}

function findSolution(n, regions) {
  const queens = new Array(n).fill(-1);
  const usedCols = new Set();
  const usedRegions = new Set();

  function isAdjacentSafe(row, col) {
    for (let r = Math.max(0, row - 1); r < row; r++) {
      if (Math.abs(queens[r] - col) <= 1) return false;
    }
    return true;
  }

  function solve(row) {
    if (row === n) return true;
    for (let col = 0; col < n; col++) {
      const region = regions[row][col];
      if (usedCols.has(col) || usedRegions.has(region)) continue;
      if (!isAdjacentSafe(row, col)) continue;
      queens[row] = col;
      usedCols.add(col);
      usedRegions.add(region);
      if (solve(row + 1)) return true;
      queens[row] = -1;
      usedCols.delete(col);
      usedRegions.delete(region);
    }
    return false;
  }

  if (!solve(0)) return null;
  return queens;
}

// ─── Puzzle Generator ───────────────────────────────────────────
function generatePuzzle(size, seed) {
  const rng = mulberry32(seed);
  const regions = generateRandomPartition(size, rng);
  if (!regions) return null;
  if (countSolutions(size, regions, 2) !== 1) return null;
  const solution = findSolution(size, regions);
  return { size, regions, _solution: solution };
}

function generateRandomPuzzle(size) {
  let seed = (Date.now() ^ (Math.random() * 0xFFFF)) & 0xFFFFFF;
  let puzzle = null;
  let attempts = 0;
  while (!puzzle && attempts < 5000) {
    puzzle = generatePuzzle(size, seed);
    seed++;
    attempts++;
  }
  return puzzle;
}

// ─── Persistence (localStorage) ─────────────────────────────────
const STORAGE_KEY = 'crowns_stats';
function loadStats() {
  try {
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
    if (data) return data;
  } catch(e) {}
  return { gamesWon: {5:0,6:0,7:0,8:0,9:0}, bestTimes: {5:null,6:null,7:null,8:null,9:null} };
}
function saveStats() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(stats));
}
let stats = loadStats();

// ─── Game State ─────────────────────────────────────────────────
let currentSize = 5;
let puzzle = null;
let placedQueens = [];
let manualMarks = new Set();
let moveHistory = [];
let timerInterval = null;
let startTime = 0;
let elapsed = 0;
let timerRunning = false;
let solved = false;

// ─── DOM refs ───────────────────────────────────────────────────
const boardEl = document.getElementById('board');
const boardContainer = document.getElementById('boardContainer');
const timerEl = document.getElementById('timer');
const messageEl = document.getElementById('message');
const overlayEl = document.getElementById('overlay');
const statsEl = document.getElementById('stats');

// ─── Difficulty Selector ────────────────────────────────────────
const diffBtns = document.querySelectorAll('.diff-btn');
diffBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const size = parseInt(btn.dataset.size);
    currentSize = size;
    diffBtns.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    newGame();
  });
});

function updateStats() {
  const won = stats.gamesWon[currentSize] || 0;
  const best = stats.bestTimes[currentSize];
  let text = `${currentSize}\u00D7${currentSize} \u2014 Vinti: ${won}`;
  if (best) text += ` \u00B7 Record: ${formatTime(best)}`;
  statsEl.textContent = text;
}

// ─── New Game ───────────────────────────────────────────────────
function newGame() {
  puzzle = generateRandomPuzzle(currentSize);
  if (!puzzle) {
    showMessage('Errore nel generare il puzzle', 'error');
    return;
  }

  const maxGridPx = Math.min(window.innerWidth - 64, 420);
  const idealSize = Math.floor(maxGridPx / puzzle.size);
  const cellSize = Math.min(60, Math.max(36, idealSize));
  document.documentElement.style.setProperty('--cell-size', cellSize + 'px');

  placedQueens = [];
  manualMarks = new Set();
  moveHistory = [];
  solved = false;
  elapsed = 0;
  stopTimer();
  timerEl.textContent = '0:00';
  hideMessage();
  overlayEl.classList.remove('visible');
  updateStats();
  renderBoard();
}

// ─── Render Board ───────────────────────────────────────────────
function renderBoard() {
  const { size, regions } = puzzle;
  boardEl.style.gridTemplateColumns = `repeat(${size}, var(--cell-size))`;
  boardEl.style.gridTemplateRows = `repeat(${size}, var(--cell-size))`;
  boardEl.innerHTML = '';

  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;

      const region = regions[r][c];
      cell.style.backgroundColor = REGION_COLORS[region % REGION_COLORS.length];

      if (r === 0 || regions[r-1][c] !== region) cell.classList.add('border-top');
      if (r === size-1 || regions[r+1]?.[c] !== region) cell.classList.add('border-bottom');
      if (c === 0 || regions[r][c-1] !== region) cell.classList.add('border-left');
      if (c === size-1 || regions[r][c+1] !== region) cell.classList.add('border-right');

      boardEl.appendChild(cell);
    }
  }

  updateVisuals();
}

// ─── Cell Interaction ────────────────────────────────────────────
let lastTapTime = 0;
let lastTapRow = -1;
let lastTapCol = -1;
let tapTimeout = null;
let isDragging = false;
let dragStartCell = null;
let dragMoved = false;
let dragMode = null;
let dragBatch = [];

function getCellFromPoint(x, y) {
  const el = document.elementFromPoint(x, y);
  if (!el) return null;
  const cell = el.closest('.cell');
  if (!cell) return null;
  return { row: parseInt(cell.dataset.row), col: parseInt(cell.dataset.col) };
}

boardContainer.addEventListener('pointerdown', onPointerDown);
boardContainer.addEventListener('pointermove', onPointerMove);
boardContainer.addEventListener('pointerup', onPointerUp);
boardContainer.addEventListener('pointerleave', onPointerUp);

function onPointerDown(e) {
  if (solved) return;
  const cell = getCellFromPoint(e.clientX, e.clientY);
  if (!cell) return;
  e.preventDefault();

  isDragging = true;
  dragMoved = false;
  dragStartCell = cell;
  dragBatch = [];

  const key = `${cell.row},${cell.col}`;
  const hasQueen = placedQueens.some(q => q.row === cell.row && q.col === cell.col);
  if (hasQueen) {
    dragMode = null;
  } else if (manualMarks.has(key)) {
    dragMode = 'remove';
  } else {
    dragMode = 'add';
  }
}

function onPointerMove(e) {
  if (!isDragging || solved || dragMode === null) return;
  e.preventDefault();
  const cell = getCellFromPoint(e.clientX, e.clientY);
  if (!cell) return;

  if (cell.row !== dragStartCell.row || cell.col !== dragStartCell.col) {
    dragMoved = true;
  }

  if (dragMoved && dragBatch.length === 0) {
    applyDragMark(dragStartCell.row, dragStartCell.col);
  }

  applyDragMark(cell.row, cell.col);
}

function applyDragMark(row, col) {
  const key = `${row},${col}`;
  if (placedQueens.some(q => q.row === row && q.col === col)) return;
  if (dragBatch.some(b => b.row === row && b.col === col)) return;

  if (dragMode === 'add' && !manualMarks.has(key)) {
    manualMarks.add(key);
    dragBatch.push({ row, col });
    if (!timerRunning) startTimer();
    updateVisuals();
  } else if (dragMode === 'remove' && manualMarks.has(key)) {
    manualMarks.delete(key);
    dragBatch.push({ row, col });
    updateVisuals();
  }
}

function onPointerUp(e) {
  if (!isDragging) return;
  isDragging = false;

  if (dragMoved && dragBatch.length > 0) {
    moveHistory.push({ type: dragMode === 'add' ? 'placeBatch' : 'removeBatch', cells: [...dragBatch] });
  } else if (!dragMoved && dragStartCell) {
    handleTap(dragStartCell.row, dragStartCell.col);
  }

  dragStartCell = null;
  dragMode = null;
  dragBatch = [];
}

function handleTap(row, col) {
  if (solved) return;

  const now = Date.now();
  const isDoubleTap = (now - lastTapTime < 350) && lastTapRow === row && lastTapCol === col;

  lastTapTime = now;
  lastTapRow = row;
  lastTapCol = col;

  if (isDoubleTap) {
    clearTimeout(tapTimeout);
    handleQueenToggle(row, col);
  } else {
    clearTimeout(tapTimeout);
    tapTimeout = setTimeout(() => {
      handleMarkToggle(row, col);
    }, 250);
  }
}

function handleQueenToggle(row, col) {
  const key = `${row},${col}`;
  const existingIdx = placedQueens.findIndex(q => q.row === row && q.col === col);

  if (existingIdx >= 0) {
    placedQueens.splice(existingIdx, 1);
    moveHistory.push({ type: 'removeQueen', row, col });
  } else {
    if (manualMarks.has(key)) {
      manualMarks.delete(key);
    }
    placedQueens.push({ row, col });
    moveHistory.push({ type: 'placeQueen', row, col });
    if (!timerRunning) startTimer();
  }

  updateVisuals();

  if (placedQueens.length === puzzle.size) {
    checkWin();
  }
}

function handleMarkToggle(row, col) {
  const existingIdx = placedQueens.findIndex(q => q.row === row && q.col === col);
  if (existingIdx >= 0) return;

  const key = `${row},${col}`;
  if (manualMarks.has(key)) {
    manualMarks.delete(key);
    moveHistory.push({ type: 'removeMark', row, col });
  } else {
    manualMarks.add(key);
    moveHistory.push({ type: 'placeMark', row, col });
    if (!timerRunning) startTimer();
  }

  updateVisuals();
}

// ─── Find Conflicts ─────────────────────────────────────────────
function findConflicts() {
  const conflicts = new Set();
  const n = placedQueens.length;

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const a = placedQueens[i], b = placedQueens[j];

      if (a.row === b.row || a.col === b.col) {
        conflicts.add(i);
        conflicts.add(j);
        continue;
      }

      if (Math.abs(a.row - b.row) <= 1 && Math.abs(a.col - b.col) <= 1) {
        conflicts.add(i);
        conflicts.add(j);
        continue;
      }

      if (puzzle.regions[a.row][a.col] === puzzle.regions[b.row][b.col]) {
        conflicts.add(i);
        conflicts.add(j);
      }
    }
  }

  return conflicts;
}

// ─── Update Visuals ─────────────────────────────────────────────
function updateVisuals() {
  const cells = boardEl.querySelectorAll('.cell');
  const conflicts = findConflicts();
  const queenMap = new Map();
  placedQueens.forEach((q, i) => queenMap.set(`${q.row},${q.col}`, i));

  const queenRows = new Set(placedQueens.map(q => q.row));
  const queenCols = new Set(placedQueens.map(q => q.col));
  const queenRegions = new Set(placedQueens.map(q => puzzle.regions[q.row][q.col]));

  const adjacentToQueen = new Set();
  for (const q of placedQueens) {
    for (let dr = -1; dr <= 1; dr++) {
      for (let dc = -1; dc <= 1; dc++) {
        if (dr === 0 && dc === 0) continue;
        adjacentToQueen.add(`${q.row + dr},${q.col + dc}`);
      }
    }
  }

  cells.forEach(cell => {
    const r = parseInt(cell.dataset.row);
    const c = parseInt(cell.dataset.col);
    const key = `${r},${c}`;

    cell.classList.remove('conflict', 'x-mark', 'x-auto');
    const oldQueen = cell.querySelector('.queen');
    if (oldQueen) oldQueen.remove();

    if (queenMap.has(key)) {
      const queenEl = document.createElement('span');
      queenEl.className = 'queen';
      queenEl.textContent = '♛';
      cell.appendChild(queenEl);

      const qIdx = queenMap.get(key);
      if (conflicts.has(qIdx)) {
        cell.classList.add('conflict');
      }
    } else if (manualMarks.has(key)) {
      cell.classList.add('x-mark');
    } else if (placedQueens.length > 0) {
      const cellRegion = puzzle.regions[r][c];
      if (queenRows.has(r) || queenCols.has(c) || queenRegions.has(cellRegion) || adjacentToQueen.has(key)) {
        cell.classList.add('x-mark', 'x-auto');
      }
    }
  });
}

// ─── Win Check ──────────────────────────────────────────────────
function checkWin() {
  if (placedQueens.length !== puzzle.size) return;

  const conflicts = findConflicts();
  if (conflicts.size > 0) return;

  const regionQueens = new Set();
  for (const q of placedQueens) {
    const region = puzzle.regions[q.row][q.col];
    if (regionQueens.has(region)) return;
    regionQueens.add(region);
  }
  if (regionQueens.size !== puzzle.size) return;

  // WIN!
  solved = true;
  stopTimer();

  stats.gamesWon[currentSize] = (stats.gamesWon[currentSize] || 0) + 1;
  if (!stats.bestTimes[currentSize] || elapsed < stats.bestTimes[currentSize]) {
    stats.bestTimes[currentSize] = elapsed;
  }
  saveStats();
  updateStats();

  showMessage('Complimenti! Puzzle risolto!', 'success');

  const isNewBest = elapsed === stats.bestTimes[currentSize];
  setTimeout(() => {
    document.getElementById('modalTime').textContent = formatTime(elapsed);
    document.getElementById('modalMsg').textContent = `${currentSize}\u00D7${currentSize} completato!` + (isNewBest ? ' Nuovo record!' : '');
    overlayEl.classList.add('visible');
  }, 600);
}

// ─── Undo ───────────────────────────────────────────────────────
function undo() {
  if (moveHistory.length === 0 || solved) return;

  const lastMove = moveHistory.pop();

  switch (lastMove.type) {
    case 'placeQueen': {
      const idx = placedQueens.findIndex(q => q.row === lastMove.row && q.col === lastMove.col);
      if (idx >= 0) placedQueens.splice(idx, 1);
      break;
    }
    case 'removeQueen':
      placedQueens.push({ row: lastMove.row, col: lastMove.col });
      break;
    case 'placeMark':
      manualMarks.delete(`${lastMove.row},${lastMove.col}`);
      break;
    case 'removeMark':
      manualMarks.add(`${lastMove.row},${lastMove.col}`);
      break;
    case 'placeBatch':
      for (const c of lastMove.cells) manualMarks.delete(`${c.row},${c.col}`);
      break;
    case 'removeBatch':
      for (const c of lastMove.cells) manualMarks.add(`${c.row},${c.col}`);
      break;
  }

  updateVisuals();
}

// ─── Timer ──────────────────────────────────────────────────────
function startTimer() {
  if (timerRunning) return;
  timerRunning = true;
  startTime = Date.now() - elapsed;
  timerInterval = setInterval(() => {
    elapsed = Date.now() - startTime;
    timerEl.textContent = formatTime(elapsed);
  }, 100);
}

function stopTimer() {
  timerRunning = false;
  clearInterval(timerInterval);
}

function formatTime(ms) {
  const totalSec = Math.floor(ms / 1000);
  const min = Math.floor(totalSec / 60);
  const sec = totalSec % 60;
  return `${min}:${sec.toString().padStart(2, '0')}`;
}

// ─── Messages ───────────────────────────────────────────────────
function showMessage(text, type) {
  messageEl.textContent = text;
  messageEl.className = 'message visible ' + type;
  setTimeout(() => hideMessage(), 3000);
}

function hideMessage() {
  messageEl.classList.remove('visible');
}

// ─── Button handlers ────────────────────────────────────────────
document.getElementById('btnUndo').addEventListener('click', undo);
document.getElementById('btnReset').addEventListener('click', () => newGame());
document.getElementById('btnNext').addEventListener('click', () => newGame());

// Keyboard support
document.addEventListener('keydown', (e) => {
  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    undo();
  }
});

// ─── Init ───────────────────────────────────────────────────────
newGame();
</script>
<script>if('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');</script>
</body>
</html>
