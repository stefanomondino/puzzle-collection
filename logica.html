<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#6C5CE7">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Puzzle">
<link rel="manifest" href="manifest.json">
<link rel="icon" href="icon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="icon.svg">
<title>Logica - Puzzle Game</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  :root {
    --bg: #faf8f5;
    --card: #ffffff;
    --primary: #6C5CE7;
    --primary-light: #e8e4fd;
    --text: #2d2d2d;
    --text-muted: #777777;
    --success: #00b894;
    --cell-size: 44px;
    --border-thin: 1px solid #d0cdc8;
    --border-thick: 2px solid #555;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    -webkit-user-select: none;
  }

  header {
    width: 100%;
    max-width: 500px;
    padding: 16px 20px 8px;
    text-align: center;
    position: relative;
  }

  header h1 {
    font-size: 28px;
    font-weight: 700;
    letter-spacing: 2px;
    color: var(--primary);
    text-transform: uppercase;
  }

  header p {
    font-size: 13px;
    color: var(--text-muted);
    margin-top: 2px;
  }

  .toolbar {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 8px 20px;
    width: 100%;
    max-width: 500px;
  }

  .timer {
    font-size: 22px;
    font-weight: 600;
    font-variant-numeric: tabular-nums;
    color: var(--text);
    min-width: 70px;
    text-align: center;
  }

  .btn {
    border: none;
    border-radius: 20px;
    padding: 8px 18px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }

  .btn:active { transform: scale(0.95); }

  .btn-outline {
    background: transparent;
    color: var(--primary);
    border: 2px solid var(--primary);
  }

  .btn-outline:hover { background: var(--primary-light); }

  .btn-primary {
    background: var(--primary);
    color: #fff;
  }

  .btn-primary:hover { background: #5a4bd6; }

  .diff-selector {
    display: flex;
    gap: 8px;
    padding: 4px 20px 12px;
    justify-content: center;
    flex-wrap: wrap;
    max-width: 500px;
  }

  .diff-btn {
    border-radius: 20px;
    border: 2px solid #d9d9d9;
    background: var(--card);
    padding: 6px 14px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--text);
  }

  .diff-btn.active {
    background: var(--primary);
    color: #fff;
    border-color: var(--primary);
  }

  .diff-btn:hover:not(.active) { background: var(--primary-light); }

  .stats {
    font-size: 12px;
    color: var(--text-muted);
    text-align: center;
    padding: 0 20px 8px;
  }

  .board-container {
    background: var(--card);
    border-radius: 16px;
    padding: 16px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.08);
    position: relative;
    touch-action: none;
  }

  .board {
    display: grid;
    gap: 0;
    position: relative;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    cursor: pointer;
    transition: background-color 0.15s;
    font-size: calc(var(--cell-size) * 0.5);
    font-weight: 600;
    color: var(--primary);
    background: #fdfcfa;
  }

  .cell.given {
    color: var(--text);
    background: #f4f2ee;
    font-weight: 700;
  }

  .cell.selected {
    background: var(--primary-light) !important;
  }

  .cell.same-number {
    background: #f0edfa;
  }

  .cell.conflict {
    color: #c62828;
  }

  .cell.conflict.selected {
    background: #fde8e8 !important;
  }

  .cell:active { filter: brightness(0.95); }

  .notes-grid {
    display: grid;
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0; left: 0;
    pointer-events: none;
  }

  .notes-grid.g9 { grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); }
  .notes-grid.g6 { grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(2, 1fr); }

  .note-num {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: calc(var(--cell-size) * 0.22);
    font-weight: 500;
    color: var(--text-muted);
    line-height: 1;
  }

  .cell {
    border-right: 1px solid #d0cdc8;
    border-bottom: 1px solid #d0cdc8;
  }

  .cell.box-right { border-right: 2px solid #555; }
  .cell.box-bottom { border-bottom: 2px solid #555; }
  .cell.box-left { border-left: 2px solid #555; }
  .cell.box-top { border-top: 2px solid #555; }

  .numpad {
    display: flex;
    gap: 6px;
    padding: 16px 8px 4px;
    justify-content: center;
    flex-wrap: wrap;
    max-width: 500px;
  }

  .numpad-btn {
    width: 40px;
    height: 44px;
    border-radius: 10px;
    border: 2px solid #d9d9d9;
    background: var(--card);
    font-size: 20px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--text);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .numpad-btn:active { transform: scale(0.92); }
  .numpad-btn.active { background: var(--primary); color: #fff; border-color: var(--primary); }
  .numpad-btn.erase { font-size: 16px; color: var(--text-muted); }
  .numpad-btn.notes-toggle { font-size: 13px; color: var(--text-muted); padding: 0 4px; width: auto; min-width: 40px; }
  .numpad-btn.notes-toggle.active { background: var(--primary-light); border-color: var(--primary); color: var(--primary); }

  .message {
    margin-top: 12px;
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    text-align: center;
    opacity: 0;
    transition: opacity 0.3s;
  }

  .message.visible { opacity: 1; }
  .message.success { background: #e8f5e9; color: var(--success); }

  .overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }

  .overlay.visible { display: flex; }

  .modal {
    background: var(--card);
    border-radius: 20px;
    padding: 32px;
    max-width: 340px;
    width: 90%;
    text-align: center;
    animation: pop 0.3s ease;
  }

  @keyframes pop {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 { font-size: 24px; margin-bottom: 8px; color: var(--success); }
  .modal p { color: var(--text-muted); margin-bottom: 20px; }
  .modal .time { font-size: 36px; font-weight: 700; color: var(--text); margin: 8px 0; }

  .instructions {
    max-width: 500px;
    padding: 12px 20px;
    text-align: center;
    font-size: 13px;
    color: var(--text-muted);
    line-height: 1.5;
  }

  @media (max-width: 420px) {
    :root { --cell-size: 38px; }
    .numpad-btn { width: 36px; height: 40px; font-size: 18px; }
  }

  @media (max-width: 350px) {
    :root { --cell-size: 34px; }
    .numpad-btn { width: 32px; height: 36px; font-size: 16px; }
  }
</style>
</head>
<body>

<header>
  <a href="index.html" style="position:absolute;left:16px;top:16px;color:var(--primary);text-decoration:none;font-size:18px;font-weight:600;">&larr; Menu</a>
  <h1>Logica</h1>
  <p>Riempi la griglia con i numeri</p>
</header>

<div class="toolbar">
  <button class="btn btn-outline" id="btnUndo">&hookleftarrow; Annulla</button>
  <div class="timer" id="timer">0:00</div>
  <button class="btn btn-outline" id="btnReset">&#10227; Reset</button>
</div>

<div class="diff-selector" id="diffSelector">
  <button class="diff-btn active" data-diff="6easy">6×6</button>
  <button class="diff-btn" data-diff="9easy">9×9 Facile</button>
  <button class="diff-btn" data-diff="9medium">9×9 Medio</button>
  <button class="diff-btn" data-diff="9hard">9×9 Difficile</button>
</div>

<p class="stats" id="stats"></p>

<div class="board-container" id="boardContainer">
  <div class="board" id="board"></div>
</div>

<div class="numpad" id="numpad"></div>

<div class="message" id="message"></div>

<p class="instructions">
  Ogni riga, colonna e riquadro deve contenere tutti i numeri senza ripetizioni.<br>
  <strong>Tap</strong> su una cella, poi scegli il numero. Usa il pulsante <strong>note</strong> per gli appunti.
</p>

<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="modalTitle">Completato!</h2>
    <div class="time" id="modalTime">0:00</div>
    <p id="modalMsg">Hai risolto il puzzle!</p>
    <button class="btn btn-primary" id="btnNext" style="margin-top:8px;">Nuovo puzzle &rarr;</button>
  </div>
</div>

<script>
// ─── Seeded PRNG (Mulberry32) ───────────────────────────────────
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function shuffleArray(arr, rng) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// ─── Difficulty Configs ─────────────────────────────────────────
const DIFF_CONFIGS = {
  '6easy':   { gridSize: 6, clues: 16, label: '6\u00D76' },
  '9easy':   { gridSize: 9, clues: 38, label: '9\u00D79 Facile' },
  '9medium': { gridSize: 9, clues: 30, label: '9\u00D79 Medio' },
  '9hard':   { gridSize: 9, clues: 26, label: '9\u00D79 Difficile' },
};

// ─── Sudoku Logic ──────────────────────────────────────────────
function getBoxDims(gridSize) {
  if (gridSize === 9) return { boxRows: 3, boxCols: 3 };
  if (gridSize === 6) return { boxRows: 2, boxCols: 3 };
  return { boxRows: 1, boxCols: gridSize };
}

function isValid(grid, gridSize, row, col, val, boxRows, boxCols) {
  for (let c = 0; c < gridSize; c++) {
    if (c !== col && grid[row][c] === val) return false;
  }
  for (let r = 0; r < gridSize; r++) {
    if (r !== row && grid[r][col] === val) return false;
  }
  const br = Math.floor(row / boxRows) * boxRows;
  const bc = Math.floor(col / boxCols) * boxCols;
  for (let r = br; r < br + boxRows; r++) {
    for (let c = bc; c < bc + boxCols; c++) {
      if (r !== row || c !== col) {
        if (grid[r][c] === val) return false;
      }
    }
  }
  return true;
}

// ─── Generate a complete valid Sudoku grid ──────────────────────
function generateSolution(gridSize, rng) {
  const { boxRows, boxCols } = getBoxDims(gridSize);
  const grid = Array.from({length: gridSize}, () => new Array(gridSize).fill(0));

  function solve(pos) {
    if (pos === gridSize * gridSize) return true;
    const r = Math.floor(pos / gridSize);
    const c = pos % gridSize;

    const nums = [];
    for (let n = 1; n <= gridSize; n++) nums.push(n);
    shuffleArray(nums, rng);

    for (const n of nums) {
      if (isValid(grid, gridSize, r, c, n, boxRows, boxCols)) {
        grid[r][c] = n;
        if (solve(pos + 1)) return true;
        grid[r][c] = 0;
      }
    }
    return false;
  }

  if (!solve(0)) return null;
  return grid;
}

// ─── Solver (for uniqueness check) ──────────────────────────────
function countSolutions(grid, gridSize, maxCount) {
  const { boxRows, boxCols } = getBoxDims(gridSize);
  const board = grid.map(row => [...row]);
  let count = 0;

  const empties = [];
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      if (board[r][c] === 0) empties.push([r, c]);
    }
  }

  function solve(idx) {
    if (idx === empties.length) { count++; return count >= maxCount; }
    const [r, c] = empties[idx];
    for (let n = 1; n <= gridSize; n++) {
      if (isValid(board, gridSize, r, c, n, boxRows, boxCols)) {
        board[r][c] = n;
        if (solve(idx + 1)) return true;
        board[r][c] = 0;
      }
    }
    return false;
  }

  solve(0);
  return count;
}

// ─── Generate Puzzle (remove cells from solution) ───────────────
function generatePuzzle(gridSize, numClues, seed) {
  const rng = mulberry32(seed);
  const solution = generateSolution(gridSize, rng);
  if (!solution) return null;

  const puzzle = solution.map(row => [...row]);
  const totalCells = gridSize * gridSize;
  const toRemove = totalCells - numClues;

  const positions = [];
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      positions.push([r, c]);
    }
  }
  shuffleArray(positions, rng);

  let removed = 0;
  for (const [r, c] of positions) {
    if (removed >= toRemove) break;
    const backup = puzzle[r][c];
    puzzle[r][c] = 0;

    if (countSolutions(puzzle, gridSize, 2) === 1) {
      removed++;
    } else {
      puzzle[r][c] = backup;
    }
  }

  return { gridSize, solution, puzzle };
}

function generateRandomPuzzle(diffKey) {
  const cfg = DIFF_CONFIGS[diffKey];
  let seed = (Date.now() ^ (Math.random() * 0xFFFF)) & 0xFFFFFF;
  let puzzle = null;
  let attempts = 0;
  while (!puzzle && attempts < 200) {
    puzzle = generatePuzzle(cfg.gridSize, cfg.clues, seed);
    if (!puzzle) seed += 7;
    attempts++;
  }
  return puzzle;
}

// ─── Persistence ────────────────────────────────────────────────
const STORAGE_KEY = 'logica_stats';
function loadStats() {
  try {
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
    if (data && data.gamesWon) return data;
  } catch(e) {}
  return {
    gamesWon: {'6easy':0,'9easy':0,'9medium':0,'9hard':0},
    bestTimes: {'6easy':null,'9easy':null,'9medium':null,'9hard':null}
  };
}
function saveStats() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(stats));
}
let stats = loadStats();

// ─── Game State ─────────────────────────────────────────────────
let currentDiff = '6easy';
let puzzleData = null;
let board = [];
let notes = [];
let givenSet = null;
let selectedCell = null;
let notesMode = false;
let moveHistory = [];
let timerInterval = null;
let startTime = 0;
let elapsed = 0;
let timerRunning = false;
let solved = false;

// ─── DOM refs ───────────────────────────────────────────────────
const boardEl = document.getElementById('board');
const boardContainer = document.getElementById('boardContainer');
const timerEl = document.getElementById('timer');
const messageEl = document.getElementById('message');
const overlayEl = document.getElementById('overlay');
const numpadEl = document.getElementById('numpad');
const statsEl = document.getElementById('stats');

// ─── Difficulty Selector ────────────────────────────────────────
const diffBtns = document.querySelectorAll('.diff-btn');
diffBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    currentDiff = btn.dataset.diff;
    diffBtns.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    newGame();
  });
});

function updateStatsDisplay() {
  const cfg = DIFF_CONFIGS[currentDiff];
  const won = stats.gamesWon[currentDiff] || 0;
  const best = stats.bestTimes[currentDiff];
  let text = `${cfg.label} \u2014 Vinti: ${won}`;
  if (best) text += ` \u00B7 Record: ${formatTime(best)}`;
  statsEl.textContent = text;
}

// ─── New Game ───────────────────────────────────────────────────
function newGame() {
  puzzleData = generateRandomPuzzle(currentDiff);

  if (!puzzleData) {
    showMessage('Errore nel generare il puzzle', 'error');
    return;
  }

  const { gridSize, puzzle } = puzzleData;

  const maxGridPx = Math.min(window.innerWidth - 64, 420);
  const idealSize = Math.floor(maxGridPx / gridSize);
  const cellSize = Math.min(gridSize === 6 ? 60 : 44, Math.max(30, idealSize));
  document.documentElement.style.setProperty('--cell-size', cellSize + 'px');

  board = puzzle.map(row => [...row]);
  notes = Array.from({length: gridSize}, () => Array.from({length: gridSize}, () => new Set()));
  givenSet = new Set();

  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      if (puzzle[r][c] !== 0) givenSet.add(`${r},${c}`);
    }
  }

  selectedCell = null;
  notesMode = false;
  moveHistory = [];
  solved = false;
  elapsed = 0;
  stopTimer();
  timerEl.textContent = '0:00';
  hideMessage();
  overlayEl.classList.remove('visible');
  updateStatsDisplay();
  buildNumpad();
  renderBoard();
}

// ─── Render Board ───────────────────────────────────────────────
function renderBoard() {
  const { gridSize } = puzzleData;
  const { boxRows, boxCols } = getBoxDims(gridSize);

  boardEl.style.gridTemplateColumns = `repeat(${gridSize}, var(--cell-size))`;
  boardEl.style.gridTemplateRows = `repeat(${gridSize}, var(--cell-size))`;
  boardEl.innerHTML = '';

  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;

      if ((c + 1) % boxCols === 0 && c < gridSize - 1) cell.classList.add('box-right');
      if ((r + 1) % boxRows === 0 && r < gridSize - 1) cell.classList.add('box-bottom');
      if (c % boxCols === 0) cell.classList.add('box-left');
      if (r % boxRows === 0) cell.classList.add('box-top');

      boardEl.appendChild(cell);
    }
  }

  updateVisuals();
}

// ─── Build Number Pad ───────────────────────────────────────────
function buildNumpad() {
  const { gridSize } = puzzleData;
  numpadEl.innerHTML = '';

  for (let n = 1; n <= gridSize; n++) {
    const btn = document.createElement('button');
    btn.className = 'numpad-btn';
    btn.textContent = n;
    btn.dataset.num = n;
    btn.addEventListener('click', () => placeNumber(n));
    numpadEl.appendChild(btn);
  }

  const eraseBtn = document.createElement('button');
  eraseBtn.className = 'numpad-btn erase';
  eraseBtn.innerHTML = '&#10005;';
  eraseBtn.title = 'Cancella';
  eraseBtn.addEventListener('click', () => placeNumber(0));
  numpadEl.appendChild(eraseBtn);

  const notesBtn = document.createElement('button');
  notesBtn.className = 'numpad-btn notes-toggle';
  notesBtn.id = 'notesToggle';
  notesBtn.textContent = 'Note';
  notesBtn.addEventListener('click', () => {
    notesMode = !notesMode;
    notesBtn.classList.toggle('active', notesMode);
  });
  numpadEl.appendChild(notesBtn);
}

// ─── Cell Interaction ───────────────────────────────────────────
boardContainer.addEventListener('pointerdown', onCellClick);

function onCellClick(e) {
  if (solved) return;
  const el = e.target.closest('.cell');
  if (!el) return;
  e.preventDefault();

  const row = parseInt(el.dataset.row);
  const col = parseInt(el.dataset.col);

  selectedCell = { row, col };
  updateVisuals();
}

// ─── Place Number ───────────────────────────────────────────────
function placeNumber(num) {
  if (!selectedCell || solved) return;
  const { row, col } = selectedCell;
  const key = `${row},${col}`;

  if (givenSet.has(key)) return;

  if (!timerRunning) startTimer();

  if (notesMode && num !== 0) {
    const oldNotes = new Set(notes[row][col]);
    const oldVal = board[row][col];

    if (oldVal !== 0) {
      moveHistory.push({ row, col, type: 'value', oldVal, newVal: 0, oldNotes: new Set(oldNotes), newNotes: new Set([num]) });
      board[row][col] = 0;
      notes[row][col] = new Set([num]);
    } else {
      const newNotes = new Set(notes[row][col]);
      if (newNotes.has(num)) newNotes.delete(num);
      else newNotes.add(num);
      moveHistory.push({ row, col, type: 'notes', oldVal: 0, newVal: 0, oldNotes, newNotes: new Set(newNotes) });
      notes[row][col] = newNotes;
    }
  } else {
    const oldVal = board[row][col];
    const oldNotes = new Set(notes[row][col]);

    if (num === oldVal) return;

    moveHistory.push({ row, col, type: 'value', oldVal, newVal: num, oldNotes, newNotes: new Set() });
    board[row][col] = num;
    notes[row][col] = new Set();

    if (num !== 0) {
      const { gridSize } = puzzleData;
      const { boxRows, boxCols } = getBoxDims(gridSize);
      for (let c = 0; c < gridSize; c++) {
        if (c !== col) notes[row][c].delete(num);
      }
      for (let r = 0; r < gridSize; r++) {
        if (r !== row) notes[r][col].delete(num);
      }
      const br = Math.floor(row / boxRows) * boxRows;
      const bc = Math.floor(col / boxCols) * boxCols;
      for (let r = br; r < br + boxRows; r++) {
        for (let c = bc; c < bc + boxCols; c++) {
          if (r !== row || c !== col) notes[r][c].delete(num);
        }
      }
    }
  }

  updateVisuals();

  if (num !== 0) {
    const { gridSize } = puzzleData;
    let full = true;
    for (let r = 0; r < gridSize && full; r++) {
      for (let c = 0; c < gridSize && full; c++) {
        if (board[r][c] === 0) full = false;
      }
    }
    if (full) checkWin();
  }
}

// ─── Find Conflicts ─────────────────────────────────────────────
function findConflicts() {
  const conflicts = new Set();
  const { gridSize } = puzzleData;
  const { boxRows, boxCols } = getBoxDims(gridSize);

  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      const val = board[r][c];
      if (val === 0) continue;

      for (let c2 = 0; c2 < gridSize; c2++) {
        if (c2 !== c && board[r][c2] === val) {
          conflicts.add(`${r},${c}`);
          conflicts.add(`${r},${c2}`);
        }
      }
      for (let r2 = 0; r2 < gridSize; r2++) {
        if (r2 !== r && board[r2][c] === val) {
          conflicts.add(`${r},${c}`);
          conflicts.add(`${r2},${c}`);
        }
      }
      const br = Math.floor(r / boxRows) * boxRows;
      const bc = Math.floor(c / boxCols) * boxCols;
      for (let r2 = br; r2 < br + boxRows; r2++) {
        for (let c2 = bc; c2 < bc + boxCols; c2++) {
          if ((r2 !== r || c2 !== c) && board[r2][c2] === val) {
            conflicts.add(`${r},${c}`);
            conflicts.add(`${r2},${c2}`);
          }
        }
      }
    }
  }

  return conflicts;
}

// ─── Update Visuals ─────────────────────────────────────────────
function updateVisuals() {
  const { gridSize } = puzzleData;
  const conflicts = findConflicts();
  const cells = boardEl.querySelectorAll('.cell');
  const selectedVal = selectedCell ? board[selectedCell.row][selectedCell.col] : 0;

  cells.forEach(cell => {
    const r = parseInt(cell.dataset.row);
    const c = parseInt(cell.dataset.col);
    const key = `${r},${c}`;
    const val = board[r][c];

    cell.classList.remove('selected', 'given', 'conflict', 'same-number');

    while (cell.firstChild) cell.removeChild(cell.firstChild);

    if (givenSet.has(key)) cell.classList.add('given');

    if (selectedCell && selectedCell.row === r && selectedCell.col === c) {
      cell.classList.add('selected');
    } else if (selectedVal !== 0 && val === selectedVal) {
      cell.classList.add('same-number');
    }

    if (conflicts.has(key) && !givenSet.has(key)) {
      cell.classList.add('conflict');
    }

    if (val !== 0) {
      cell.textContent = val;
    } else if (notes[r][c].size > 0) {
      const ng = document.createElement('div');
      ng.className = 'notes-grid ' + (gridSize === 6 ? 'g6' : 'g9');
      for (let n = 1; n <= gridSize; n++) {
        const nd = document.createElement('div');
        nd.className = 'note-num';
        if (notes[r][c].has(n)) nd.textContent = n;
        ng.appendChild(nd);
      }
      cell.appendChild(ng);
    }
  });
}

// ─── Win Check ──────────────────────────────────────────────────
function checkWin() {
  const conflicts = findConflicts();
  if (conflicts.size > 0) return;

  const { gridSize, solution } = puzzleData;
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      if (board[r][c] !== solution[r][c]) return;
    }
  }

  // WIN!
  solved = true;
  stopTimer();

  stats.gamesWon[currentDiff] = (stats.gamesWon[currentDiff] || 0) + 1;
  if (!stats.bestTimes[currentDiff] || elapsed < stats.bestTimes[currentDiff]) {
    stats.bestTimes[currentDiff] = elapsed;
  }
  saveStats();
  updateStatsDisplay();

  showMessage('Complimenti! Puzzle risolto!', 'success');

  const cfg = DIFF_CONFIGS[currentDiff];
  const isNewBest = elapsed === stats.bestTimes[currentDiff];
  setTimeout(() => {
    document.getElementById('modalTime').textContent = formatTime(elapsed);
    document.getElementById('modalMsg').textContent = `${cfg.label} completato!` + (isNewBest ? ' Nuovo record!' : '');
    overlayEl.classList.add('visible');
  }, 600);
}

// ─── Undo ───────────────────────────────────────────────────────
function undo() {
  if (moveHistory.length === 0 || solved) return;

  const move = moveHistory.pop();
  board[move.row][move.col] = move.oldVal;
  notes[move.row][move.col] = move.oldNotes;
  updateVisuals();
}

// ─── Timer ──────────────────────────────────────────────────────
function startTimer() {
  if (timerRunning) return;
  timerRunning = true;
  startTime = Date.now() - elapsed;
  timerInterval = setInterval(() => {
    elapsed = Date.now() - startTime;
    timerEl.textContent = formatTime(elapsed);
  }, 100);
}

function stopTimer() {
  timerRunning = false;
  clearInterval(timerInterval);
}

function formatTime(ms) {
  const totalSec = Math.floor(ms / 1000);
  const min = Math.floor(totalSec / 60);
  const sec = totalSec % 60;
  return `${min}:${sec.toString().padStart(2, '0')}`;
}

// ─── Messages ───────────────────────────────────────────────────
function showMessage(text, type) {
  messageEl.textContent = text;
  messageEl.className = 'message visible ' + type;
  setTimeout(() => hideMessage(), 3000);
}

function hideMessage() {
  messageEl.classList.remove('visible');
}

// ─── Button handlers ────────────────────────────────────────────
document.getElementById('btnUndo').addEventListener('click', undo);
document.getElementById('btnReset').addEventListener('click', () => newGame());
document.getElementById('btnNext').addEventListener('click', () => newGame());

// Keyboard support
document.addEventListener('keydown', (e) => {
  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    undo();
    return;
  }
  if (solved) return;

  if (selectedCell && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
    e.preventDefault();
    const { gridSize } = puzzleData;
    let { row, col } = selectedCell;
    if (e.key === 'ArrowUp') row = Math.max(0, row - 1);
    if (e.key === 'ArrowDown') row = Math.min(gridSize - 1, row + 1);
    if (e.key === 'ArrowLeft') col = Math.max(0, col - 1);
    if (e.key === 'ArrowRight') col = Math.min(gridSize - 1, col + 1);
    selectedCell = { row, col };
    updateVisuals();
    return;
  }

  const num = parseInt(e.key);
  if (num >= 0 && num <= (puzzleData ? puzzleData.gridSize : 9)) {
    placeNumber(num === 0 ? 0 : num);
  }
  if (e.key === 'Backspace' || e.key === 'Delete') {
    placeNumber(0);
  }
  if (e.key === 'n' || e.key === 'N') {
    notesMode = !notesMode;
    const tb = document.getElementById('notesToggle');
    if (tb) tb.classList.toggle('active', notesMode);
  }
});

// ─── Init ───────────────────────────────────────────────────────
newGame();
</script>
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(regs => {
    Promise.all(regs.map(r => r.unregister())).then(() => {
      navigator.serviceWorker.register('sw.js');
    });
  });
}
</script>
</body>
</html>
