<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#6C5CE7">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Puzzle">
<link rel="manifest" href="manifest.json">
<link rel="icon" href="icon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="icon.svg">
<title>Scaletta - Puzzle Game</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

  :root {
    --bg: #faf8f5;
    --card: #ffffff;
    --primary: #6C5CE7;
    --primary-light: #e8e4fd;
    --text: #2d2d2d;
    --text-muted: #777777;
    --success: #00b894;
    --error: #e74c3c;
    --warning: #f39c12;
    --locked: #e8e6e1;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    -webkit-user-select: none;
  }

  header {
    width: 100%;
    max-width: 500px;
    padding: 16px 20px 4px;
    text-align: center;
    position: relative;
  }

  header h1 { font-size: 28px; font-weight: 700; letter-spacing: 2px; color: var(--primary); text-transform: uppercase; }
  header p { font-size: 13px; color: var(--text-muted); margin-top: 2px; }

  .back-btn { position: absolute; left: 16px; top: 18px; text-decoration: none; font-size: 22px; color: var(--primary); font-weight: 600; }
  .stats-btn { position: absolute; right: 16px; top: 18px; font-size: 20px; background: none; border: none; cursor: pointer; color: var(--primary); }

  .toolbar {
    display: flex; align-items: center; justify-content: center;
    gap: 12px; padding: 6px 20px; width: 100%; max-width: 500px;
  }

  .btn {
    border: none; border-radius: 20px; padding: 8px 16px; font-size: 13px; font-weight: 600;
    cursor: pointer; transition: all 0.15s; background: var(--card); color: var(--text);
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
  }
  .btn:active { transform: scale(0.95); }
  .btn.primary { background: var(--primary); color: #fff; }

  .timer { font-size: 22px; font-weight: 600; font-variant-numeric: tabular-nums; color: var(--text); min-width: 70px; text-align: center; }

  /* --- Phase Banner --- */
  .phase-banner {
    font-size: 13px; font-weight: 700; color: var(--primary); text-transform: uppercase;
    letter-spacing: 1px; padding: 4px 16px; margin: 4px 0;
  }

  /* --- Board --- */
  .board-container {
    background: var(--card); border-radius: 16px; padding: 12px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.08);
    width: 100%; max-width: 420px; margin: 4px auto;
  }

  .ladder { display: flex; flex-direction: column; gap: 0; align-items: center; }

  .ladder-row {
    display: flex; gap: 3px; align-items: center; padding: 3px 0;
    border-radius: 10px; transition: all 0.2s; position: relative;
    width: 100%; justify-content: center;
  }

  .ladder-row.locked { opacity: 0.5; }
  .ladder-row.active { background: var(--primary-light); }
  .ladder-row.swap-selected { background: #fff3cd; box-shadow: 0 0 0 2px var(--warning); }
  .ladder-row.correct-order { background: #e6f9f3; }
  .ladder-row.dragging { opacity: 0.4; }

  .row-label {
    width: 22px; font-size: 11px; font-weight: 700; color: var(--text-muted);
    text-align: center; flex-shrink: 0;
  }
  .row-label.top { color: var(--success); }
  .row-label.bottom { color: var(--success); }

  .connector {
    display: flex; justify-content: center; height: 10px; width: 100%;
  }
  .connector-line {
    width: 2px; height: 100%; background: #e0ddd8; transition: background 0.3s;
  }
  .connector-line.valid { background: var(--success); width: 3px; }

  .cell {
    width: 42px; height: 42px; border: 2px solid #d0cdc8; border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; font-weight: 700; text-transform: uppercase;
    transition: all 0.15s; background: #fff;
  }

  .cell.filled { border-color: var(--primary); color: var(--primary); background: var(--primary-light); }
  .cell.given { border-color: var(--success); color: var(--success); background: #e6f9f3; }
  .cell.locked-cell { background: var(--locked); border-color: #ccc; color: #aaa; }
  .cell.typing { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(108,92,231,0.3); }
  .cell.error { border-color: var(--error); background: #fdeaea; animation: shake 0.3s; }

  @keyframes shake {
    25% { transform: translateX(-3px); } 50% { transform: translateX(3px); } 75% { transform: translateX(-2px); }
  }

  /* --- Clue Area --- */
  .clue-area {
    width: 100%; max-width: 420px; padding: 8px 16px;
  }

  .clue-card {
    background: var(--card); border-radius: 12px; padding: 12px 16px;
    box-shadow: 0 1px 6px rgba(0,0,0,0.08); margin-bottom: 6px;
    cursor: pointer; transition: all 0.15s; border: 2px solid transparent;
    display: flex; align-items: center; gap: 10px;
  }
  .clue-card.active { border-color: var(--primary); background: var(--primary-light); }
  .clue-card.solved { border-color: var(--success); background: #e6f9f3; opacity: 0.7; }
  .clue-card:active { transform: scale(0.98); }

  .clue-num {
    width: 26px; height: 26px; border-radius: 50%; background: var(--primary);
    color: #fff; font-size: 13px; font-weight: 700;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  }
  .clue-card.solved .clue-num { background: var(--success); }

  .clue-text { font-size: 14px; color: var(--text); flex: 1; }
  .clue-answer { font-size: 14px; font-weight: 700; color: var(--success); text-transform: uppercase; }

  /* --- Reorder instructions --- */
  .reorder-hint {
    text-align: center; font-size: 13px; color: var(--text-muted);
    padding: 8px 16px; max-width: 420px;
  }

  /* --- Keyboard --- */
  .keyboard {
    width: 100%; max-width: 500px; padding: 6px 4px;
    margin-top: auto; padding-bottom: env(safe-area-inset-bottom, 6px);
  }
  .keyboard.hidden { display: none; }

  .kb-row { display: flex; justify-content: center; gap: 4px; margin-bottom: 4px; }

  .kb-key {
    min-width: 30px; height: 44px; border: none; border-radius: 8px;
    background: var(--card); color: var(--text); font-size: 17px; font-weight: 600;
    cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.12);
    display: flex; align-items: center; justify-content: center;
    text-transform: uppercase; transition: background 0.1s; flex: 1; max-width: 40px;
  }
  .kb-key:active { background: var(--primary-light); }
  .kb-key.wide { min-width: 52px; max-width: 68px; font-size: 13px; flex: 1.5; }
  .kb-key.action { background: var(--primary); color: #fff; }
  .kb-key.action:active { background: #5a4bd1; }

  /* --- Modals --- */
  .modal-overlay {
    display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.4);
    z-index: 100; align-items: center; justify-content: center; padding: 20px;
  }
  .modal-overlay.show { display: flex; }

  .modal {
    background: var(--card); border-radius: 20px; padding: 28px 24px;
    max-width: 360px; width: 100%; text-align: center;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2); animation: pop 0.3s ease;
  }
  @keyframes pop { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

  .modal h2 { font-size: 22px; color: var(--primary); margin-bottom: 12px; }
  .modal p { color: var(--text-muted); margin-bottom: 10px; font-size: 14px; }

  .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 14px 0; }
  .stat-item { background: var(--primary-light); border-radius: 12px; padding: 10px 8px; }
  .stat-item .num { font-size: 26px; font-weight: 700; color: var(--primary); }
  .stat-item .lbl { font-size: 11px; color: var(--text-muted); margin-top: 2px; }

  .modal .btn { margin-top: 14px; background: var(--primary); color: #fff; padding: 12px 28px; font-size: 15px; border-radius: 24px; }

  p.stats { text-align: center; font-size: 12px; color: var(--text-muted); padding: 2px; }

  .instructions {
    max-width: 460px; padding: 12px 24px; font-size: 12px;
    color: var(--text-muted); line-height: 1.5; text-align: center;
  }

  @media (max-width: 380px) {
    .cell { width: 36px; height: 36px; font-size: 16px; }
    .kb-key { height: 40px; font-size: 15px; }
    .clue-card { padding: 10px 12px; }
  }
</style>
</head>
<body>

<header>
  <a href="index.html" class="back-btn">&larr;</a>
  <h1>Scaletta</h1>
  <p>Scala di parole con indizi</p>
  <button class="stats-btn" onclick="showStats()" title="Statistiche">&#x1F3C6;</button>
</header>

<div class="toolbar">
  <button class="btn" onclick="useHint()">&#128161; Aiuto</button>
  <div class="timer" id="timer">00:00</div>
  <button class="btn" onclick="newGame()">&#10227; Nuovo</button>
</div>

<div class="phase-banner" id="phaseBanner">Fase 1: Risolvi gli indizi</div>

<div class="board-container">
  <div class="ladder" id="ladder"></div>
</div>

<div class="clue-area" id="clueArea"></div>
<div class="reorder-hint" id="reorderHint"></div>

<p class="stats" id="statsLine"></p>

<div class="keyboard" id="keyboard"></div>

<p class="instructions">
  <strong>Fase 1</strong>: risolvi i 5 indizi e scopri le parole.
  <strong>Fase 2</strong>: riordina le parole per formare una scala (ogni coppia differisce di 1 lettera).
  <strong>Fase 3</strong>: indovina la prima e l'ultima parola con l'indizio tematico.
</p>

<!-- Stats Modal -->
<div class="modal-overlay" id="statsModal">
  <div class="modal">
    <h2>Statistiche</h2>
    <div class="stat-grid" id="statsGrid"></div>
    <button class="btn" onclick="closeModal('statsModal')">Chiudi</button>
  </div>
</div>

<!-- Win Modal -->
<div class="modal-overlay" id="winModal">
  <div class="modal">
    <h2>Complimenti!</h2>
    <p id="winMsg"></p>
    <button class="btn" onclick="closeModal('winModal'); newGame();">Nuova Scaletta &rarr;</button>
  </div>
</div>

<script>
// --- Seeded PRNG (mulberry32) ---
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function shuffleArray(arr, rng) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// --- Puzzle Database ---
// Each puzzle: words[0]=top, words[6]=bottom, words[1..5]=middle (in correct ladder order)
// clues[0..4] = clues for words[1..5] respectively
// tbClue = shared clue for top & bottom words
const PUZZLES = [
  {
    words: ['monte','conte','conto','canto','tanto','tango','fango'],
    clues: ['Titolo nobiliare','Si paga al ristorante','Melodia vocale','Una grande quantità','Ballo argentino'],
    tbClue: 'Elementi del paesaggio'
  },
  {
    words: ['mare','male','mole','sole','sale','sane','cane'],
    clues: ['Contrario di bene','Massa, grande quantità','Stella del nostro sistema','Condimento bianco per i cibi','In buona salute (femminile plurale)'],
    tbClue: 'Compagni d\'estate in spiaggia'
  },
  {
    words: ['vino','vano','varo','faro','fare','dare','dire'],
    clues: ['Inutile, senza risultato','Messa in acqua di una nave','Torre luminosa per le navi','Verbo di azione','Opposto di ricevere'],
    tbClue: 'A tavola tra amici'
  },
  {
    words: ['cura','dura','duna','luna','lana','lava','lama'],
    clues: ['Resistente, non morbida','Collina di sabbia','Satellite della Terra','Fibra della pecora','Materiale fuso dal vulcano'],
    tbClue: 'Dal dottore'
  },
  {
    words: ['porta','posta','costa','cesta','testa','tenta','tenda'],
    clues: ['Si ritira all\'ufficio postale','Litorale, riva del mare','Contenitore intrecciato di vimini','Parte del corpo con il cervello','Prova, fa un tentativo'],
    tbClue: 'Si aprono e si chiudono'
  },
  {
    words: ['nero','vero','vera','vena','cena','cera','sera'],
    clues: ['Autentico, non falso','Anello nuziale','Vaso sanguigno','Pasto della sera','Materiale delle candele'],
    tbClue: 'Calano insieme'
  },
  {
    words: ['mano','meno','melo','mela','tela','tesa','resa'],
    clues: ['Contrario di più','Albero che dà le mele','Frutto rosso o verde','Tessuto del pittore','Stirata, sotto tensione'],
    tbClue: 'Fine della battaglia'
  },
  {
    words: ['torre','corre','corte','conte','conto','canto','santo'],
    clues: ['Si muove velocemente','Residenza del re','Titolo nobiliare','Calcolo da pagare','Melodia vocale'],
    tbClue: 'Nel medioevo'
  },
  {
    words: ['vita','vite','vile','bile','file','fila','filo'],
    clues: ['Pianta dell\'uva o pezzo a spirale','Codardo, senza coraggio','Liquido prodotto dal fegato','Documenti digitali','Coda di persone in attesa'],
    tbClue: 'Appeso a un...'
  },
  {
    words: ['sole','sola','soda','coda','cola','cosa','casa'],
    clues: ['Senza compagnia','Bevanda frizzante','Appendice degli animali','Scorre lentamente, gocciola','Oggetto, affare'],
    tbClue: 'Dove stare d\'estate'
  },
  {
    words: ['muro','mura','mira','mina','mena','mela','meta'],
    clues: ['Pareti difensive della città','Punto d\'osservazione del tiratore','Esplosivo sotterraneo','Conduce, porta','Frutto rosso o verde'],
    tbClue: 'Obiettivo da raggiungere'
  },
  {
    words: ['toro','tono','topo','tipo','tiro','tira','mira'],
    clues: ['Altezza di un suono','Piccolo roditore','Genere, categoria','Lancio verso un bersaglio','Trascina, esercita forza'],
    tbClue: 'Nell\'arena'
  },
  {
    words: ['palla','balla','bolla','molla','molle','molte','monte'],
    clues: ['Danza o grossa bugia','Sfera d\'aria nell\'acqua','Meccanismo elastico a spirale','Non dure, cedevoli','Tante, in gran numero'],
    tbClue: 'Giochi all\'aperto'
  },
  {
    words: ['rosa','roba','roma','rima','rime','rive','vive'],
    clues: ['Oggetti, cose in generale','Capitale d\'Italia','Suono uguale a fine verso','Poesie in versi','Sponde di un fiume'],
    tbClue: 'Il fiore che sboccia'
  },
  {
    words: ['lento','letto','lesto','resto','gesto','gusto','busto'],
    clues: ['Mobile per dormire','Rapido, svelto','Ciò che rimane','Movimento espressivo del corpo','Uno dei cinque sensi'],
    tbClue: 'Opposti nel ritmo'
  },
  {
    words: ['peso','pesa','pena','cena','cera','cero','cera'],
    clues: ['Misura con la bilancia','Sofferenza, punizione','Pasto della sera','Materiale delle candele','Candelabro liturgico'],
    tbClue: 'Sul piatto della bilancia'
  },
  {
    words: ['lago','lato','dato','dito','divo','dive','dire'],
    clues: ['Fianco, parte laterale','Informazione, numero','Appendice della mano','Persona famosa dello spettacolo','Celebrità femminili'],
    tbClue: 'Specchio naturale e parole'
  },
  {
    words: ['nave','neve','nove','note','noia','nona','dona'],
    clues: ['Precipitazione bianca invernale','Numero dopo l\'otto','Segni musicali sul pentagramma','Mancanza di interesse, tedio','Nonna, o la nona ora'],
    tbClue: 'Attraversa l\'acqua e il cuore'
  },
  {
    words: ['fuga','foga','foca','fora','foro','moro','muro'],
    clues: ['Impeto, grande energia','Mammifero marino','Perfora, fa un buco','Apertura, buco','Di carnagione scura'],
    tbClue: 'Scappare e costruire'
  },
  {
    words: ['rete','rate','rane','rane','lane','lame','lume'],
    clues: ['Quote di un pagamento','Anfibi che gracidano','Fibre tessili plurale','Lame di coltello','Piccola luce, candela'],
    tbClue: 'Cattura e illumina'
  }
];

// --- Helpers ---
function diffCount(a, b) {
  if (a.length !== b.length) return Infinity;
  let d = 0;
  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) d++;
  return d;
}

function isValidLadder(words) {
  for (let i = 1; i < words.length; i++) {
    if (diffCount(words[i - 1], words[i]) !== 1) return false;
  }
  return true;
}

// --- Persistence (localStorage) ---
const STORAGE_KEY = 'scaletta_stats';

function loadStats() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || defaultStats(); }
  catch { return defaultStats(); }
}
function defaultStats() {
  return { gamesPlayed: 0, gamesWon: 0, currentStreak: 0, maxStreak: 0, lastPlayed: '', bestTimes: {} };
}
function saveStats(s) { localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }

// --- Game State ---
let puzzle = null;         // Current puzzle data
let phase = 1;             // 1=clues, 2=reorder, 3=top/bottom
let solvedClues = [];      // Array of {word, clueIdx} for solved clues
let activeClueIdx = -1;    // Which clue is being answered
let typingBuffer = '';      // Current typing input
let middleOrder = [];      // Current order of middle words (phase 2)
let swapSelected = -1;     // Index selected for swap (phase 2)
let topWord = '';           // Player's top word (phase 3)
let bottomWord = '';        // Player's bottom word (phase 3)
let phase3Focus = 'top';   // Which word is being typed in phase 3
let phase3Col = 0;         // Current column in phase 3
let timerInterval = null;
let startTime = 0;
let elapsed = 0;
let gameWon = false;
let hintsUsed = 0;
let isMobile = false;
let usedPuzzles = [];

// --- DOM ---
const ladderEl = document.getElementById('ladder');
const timerEl = document.getElementById('timer');
const keyboardEl = document.getElementById('keyboard');
const clueAreaEl = document.getElementById('clueArea');
const phaseBannerEl = document.getElementById('phaseBanner');
const reorderHintEl = document.getElementById('reorderHint');
const statsLineEl = document.getElementById('statsLine');

// --- Init ---
function init() {
  isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  buildKeyboard();
  if (!isMobile) keyboardEl.classList.add('hidden');
  document.addEventListener('keydown', onKeyDown);
  newGame();
  updateStatsLine();
}

// --- New Game ---
function newGame() {
  gameWon = false;
  hintsUsed = 0;
  stopTimer();

  // Pick a random puzzle
  const seed = Date.now();
  const rng = mulberry32(seed);
  let idx;
  const validPuzzles = PUZZLES.filter((_, i) => !usedPuzzles.includes(i));
  if (validPuzzles.length === 0) usedPuzzles = [];
  const pool = usedPuzzles.length < PUZZLES.length
    ? PUZZLES.map((p, i) => i).filter(i => !usedPuzzles.includes(i))
    : PUZZLES.map((_, i) => i);
  idx = pool[Math.floor(rng() * pool.length)];
  usedPuzzles.push(idx);

  puzzle = JSON.parse(JSON.stringify(PUZZLES[idx]));

  // Validate puzzle integrity
  if (!isValidLadder(puzzle.words)) {
    console.warn('Invalid puzzle ladder at index', idx);
  }

  phase = 1;
  solvedClues = [];
  activeClueIdx = 0;
  typingBuffer = '';
  middleOrder = [];
  swapSelected = -1;
  topWord = '';
  bottomWord = '';
  phase3Focus = 'top';
  phase3Col = 0;

  render();
  startTimer();
}

// --- Rendering ---
function render() {
  renderPhaseBanner();
  renderLadder();
  renderClueArea();
  renderReorderHint();
}

function renderPhaseBanner() {
  if (phase === 1) phaseBannerEl.textContent = 'Fase 1: Risolvi gli indizi';
  else if (phase === 2) phaseBannerEl.textContent = 'Fase 2: Riordina la scala';
  else if (phase === 3) phaseBannerEl.textContent = 'Fase 3: Prima e ultima parola';
  else phaseBannerEl.textContent = '';
}

function renderLadder() {
  ladderEl.innerHTML = '';
  const wordLen = puzzle.words[0].length;
  const totalRows = puzzle.words.length;

  for (let r = 0; r < totalRows; r++) {
    // Connector
    if (r > 0) {
      const conn = document.createElement('div');
      conn.className = 'connector';
      const line = document.createElement('div');
      line.className = 'connector-line';

      if (phase === 2 || phase === 3 || gameWon) {
        const wAbove = getDisplayWord(r - 1);
        const wBelow = getDisplayWord(r);
        if (wAbove && wBelow && wAbove.length === wBelow.length && diffCount(wAbove, wBelow) === 1) {
          line.classList.add('valid');
        }
      }
      conn.appendChild(line);
      ladderEl.appendChild(conn);
    }

    const rowDiv = document.createElement('div');
    rowDiv.className = 'ladder-row';

    const isTop = r === 0;
    const isBottom = r === totalRows - 1;
    const isMiddle = !isTop && !isBottom;
    const middleIdx = isMiddle ? r - 1 : -1;

    // Row label
    const label = document.createElement('div');
    label.className = 'row-label';
    if (isTop) { label.textContent = '▲'; label.classList.add('top'); }
    else if (isBottom) { label.textContent = '▼'; label.classList.add('bottom'); }
    else label.textContent = r;
    rowDiv.appendChild(label);

    // Determine what to show in cells
    let displayWord = '';
    let cellState = 'empty'; // empty, locked, filled, given, typing

    if (phase === 1) {
      if (isTop || isBottom) {
        cellState = 'locked';
      } else {
        const solved = solvedClues.find(s => s.clueIdx === middleIdx);
        if (solved) {
          displayWord = solved.word;
          cellState = 'filled';
        } else if (activeClueIdx === middleIdx) {
          displayWord = typingBuffer;
          cellState = 'typing';
        }
      }
    } else if (phase === 2) {
      if (isTop || isBottom) {
        cellState = 'locked';
      } else {
        displayWord = middleOrder[middleIdx] || '';
        cellState = 'filled';
        // Make row tappable for swap
        const mi = middleIdx;
        rowDiv.style.cursor = 'pointer';
        rowDiv.addEventListener('click', () => handleSwapTap(mi));
        if (swapSelected === middleIdx) rowDiv.classList.add('swap-selected');
      }
    } else if (phase === 3 || gameWon) {
      if (isTop) {
        displayWord = topWord;
        cellState = phase3Focus === 'top' && !gameWon ? 'typing' : (topWord.length === wordLen ? 'given' : 'empty');
        if (!gameWon && isTop) {
          rowDiv.style.cursor = 'pointer';
          rowDiv.addEventListener('click', () => { phase3Focus = 'top'; phase3Col = topWord.length < wordLen ? topWord.length : wordLen - 1; render(); });
        }
      } else if (isBottom) {
        displayWord = bottomWord;
        cellState = phase3Focus === 'bottom' && !gameWon ? 'typing' : (bottomWord.length === wordLen ? 'given' : 'empty');
        if (!gameWon && isBottom) {
          rowDiv.style.cursor = 'pointer';
          rowDiv.addEventListener('click', () => { phase3Focus = 'bottom'; phase3Col = bottomWord.length < wordLen ? bottomWord.length : wordLen - 1; render(); });
        }
      } else {
        displayWord = middleOrder[middleIdx] || '';
        cellState = 'given';
      }
    }

    if (gameWon) {
      displayWord = puzzle.words[r];
      cellState = 'given';
      rowDiv.classList.add('correct-order');
    }

    if (phase === 3 && !gameWon) {
      if (isTop && phase3Focus === 'top') rowDiv.classList.add('active');
      if (isBottom && phase3Focus === 'bottom') rowDiv.classList.add('active');
    }

    // Render cells
    for (let c = 0; c < wordLen; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      const ch = displayWord[c] || '';
      cell.textContent = ch;

      if (cellState === 'locked') cell.classList.add('locked-cell');
      else if (cellState === 'filled') cell.classList.add('filled');
      else if (cellState === 'given') cell.classList.add('given');
      else if (cellState === 'typing') {
        if (c < displayWord.length) cell.classList.add('filled');
        else if (c === displayWord.length) cell.classList.add('typing');
      }

      rowDiv.appendChild(cell);
    }

    ladderEl.appendChild(rowDiv);
  }
}

function getDisplayWord(r) {
  const totalRows = puzzle.words.length;
  if (r === 0) return topWord || null;
  if (r === totalRows - 1) return bottomWord || null;
  const mi = r - 1;
  if (phase === 1) {
    const solved = solvedClues.find(s => s.clueIdx === mi);
    return solved ? solved.word : null;
  }
  return middleOrder[mi] || null;
}

function renderClueArea() {
  clueAreaEl.innerHTML = '';

  if (phase === 1) {
    // Shuffle clue display order (but keep track of which clue index each refers to)
    const clueIndices = puzzle.clues.map((_, i) => i);

    for (const ci of clueIndices) {
      const card = document.createElement('div');
      card.className = 'clue-card';

      const solved = solvedClues.find(s => s.clueIdx === ci);
      if (solved) {
        card.classList.add('solved');
      } else if (ci === activeClueIdx) {
        card.classList.add('active');
      }

      const num = document.createElement('div');
      num.className = 'clue-num';
      num.textContent = ci + 1;
      card.appendChild(num);

      const text = document.createElement('div');
      text.className = 'clue-text';
      text.textContent = puzzle.clues[ci];
      card.appendChild(text);

      if (solved) {
        const ans = document.createElement('div');
        ans.className = 'clue-answer';
        ans.textContent = solved.word;
        card.appendChild(ans);
      }

      if (!solved) {
        card.addEventListener('click', () => {
          activeClueIdx = ci;
          typingBuffer = '';
          render();
        });
      }

      clueAreaEl.appendChild(card);
    }
  } else if (phase === 3 && !gameWon) {
    const card = document.createElement('div');
    card.className = 'clue-card active';
    const num = document.createElement('div');
    num.className = 'clue-num';
    num.textContent = '?';
    card.appendChild(num);
    const text = document.createElement('div');
    text.className = 'clue-text';
    text.innerHTML = '<strong>Indizio:</strong> ' + puzzle.tbClue;
    card.appendChild(text);
    clueAreaEl.appendChild(card);
  }
}

function renderReorderHint() {
  if (phase === 2) {
    reorderHintEl.textContent = 'Tocca due righe per scambiarle. Ogni parola deve differire di 1 lettera dalla vicina.';
  } else {
    reorderHintEl.textContent = '';
  }
}

// --- Phase 1: Solve Clues ---
function submitClueAnswer() {
  if (phase !== 1 || activeClueIdx < 0) return;

  const answer = typingBuffer.toLowerCase().trim();
  const expected = puzzle.words[activeClueIdx + 1]; // words[1..5] correspond to clues[0..4]

  if (answer === expected) {
    solvedClues.push({ word: expected, clueIdx: activeClueIdx });
    typingBuffer = '';

    if (solvedClues.length === puzzle.clues.length) {
      // All clues solved -> Phase 2
      startPhase2();
    } else {
      // Move to next unsolved clue
      const unsolved = puzzle.clues.map((_, i) => i).filter(i => !solvedClues.find(s => s.clueIdx === i));
      activeClueIdx = unsolved[0];
    }
  } else {
    // Wrong answer - shake
    typingBuffer = '';
    render();
    const rows = ladderEl.querySelectorAll('.ladder-row');
    const targetRow = rows[activeClueIdx + 1];
    if (targetRow) {
      targetRow.querySelectorAll('.cell').forEach(c => {
        c.classList.add('error');
        setTimeout(() => c.classList.remove('error'), 400);
      });
    }
    return;
  }

  render();
}

// --- Phase 2: Reorder ---
function startPhase2() {
  phase = 2;
  swapSelected = -1;
  // Place solved words in scrambled order
  const seed2 = Date.now();
  const rng2 = mulberry32(seed2);
  const solvedWords = solvedClues
    .sort((a, b) => a.clueIdx - b.clueIdx)
    .map(s => s.word);
  middleOrder = shuffleArray(solvedWords, rng2);

  // Make sure it's not already in correct order
  const correct = puzzle.words.slice(1, -1);
  if (middleOrder.join(',') === correct.join(',')) {
    // Swap first two
    [middleOrder[0], middleOrder[1]] = [middleOrder[1], middleOrder[0]];
  }

  render();
}

function handleSwapTap(middleIdx) {
  if (phase !== 2) return;

  if (swapSelected < 0) {
    swapSelected = middleIdx;
  } else if (swapSelected === middleIdx) {
    swapSelected = -1;
  } else {
    // Swap
    [middleOrder[swapSelected], middleOrder[middleIdx]] = [middleOrder[middleIdx], middleOrder[swapSelected]];
    swapSelected = -1;

    // Check if order is correct
    const fullLadder = [puzzle.words[0], ...middleOrder, puzzle.words[puzzle.words.length - 1]];
    // We only check middle is valid internally
    let middleValid = true;
    for (let i = 1; i < middleOrder.length; i++) {
      if (diffCount(middleOrder[i - 1], middleOrder[i]) !== 1) { middleValid = false; break; }
    }
    // Also check connection to top/bottom neighbors
    if (middleValid) {
      const topNeighborOk = diffCount(puzzle.words[0], middleOrder[0]) === 1;
      const botNeighborOk = diffCount(middleOrder[middleOrder.length - 1], puzzle.words[puzzle.words.length - 1]) === 1;
      if (topNeighborOk && botNeighborOk) {
        startPhase3();
        return;
      }
    }
  }
  render();
}

// --- Phase 3: Top & Bottom ---
function startPhase3() {
  phase = 3;
  topWord = '';
  bottomWord = '';
  phase3Focus = 'top';
  phase3Col = 0;
  render();
}

function submitPhase3Word() {
  if (phase !== 3) return;
  const wordLen = puzzle.words[0].length;

  if (phase3Focus === 'top') {
    if (topWord.length === wordLen) {
      if (topWord === puzzle.words[0]) {
        // Correct top word
        phase3Focus = 'bottom';
        phase3Col = 0;
        if (bottomWord === puzzle.words[puzzle.words.length - 1]) {
          winGame();
          return;
        }
      } else {
        // Wrong
        shakeRow(0);
        topWord = '';
      }
    }
  } else {
    if (bottomWord.length === wordLen) {
      if (bottomWord === puzzle.words[puzzle.words.length - 1]) {
        // Correct bottom word
        phase3Focus = 'top';
        if (topWord === puzzle.words[0]) {
          winGame();
          return;
        }
      } else {
        shakeRow(puzzle.words.length - 1);
        bottomWord = '';
      }
    }
  }
  render();
}

function shakeRow(r) {
  render();
  const rows = ladderEl.querySelectorAll('.ladder-row');
  if (rows[r]) {
    rows[r].querySelectorAll('.cell').forEach(c => {
      c.classList.add('error');
      setTimeout(() => c.classList.remove('error'), 400);
    });
  }
}

// --- Win ---
function winGame() {
  gameWon = true;
  stopTimer();

  const stats = loadStats();
  stats.gamesPlayed++;
  stats.gamesWon++;
  const today = new Date().toISOString().slice(0, 10);
  const yday = new Date(Date.now() - 86400000).toISOString().slice(0, 10);
  if (stats.lastPlayed === today || stats.lastPlayed === yday) {
    stats.currentStreak++;
  } else {
    stats.currentStreak = 1;
  }
  stats.maxStreak = Math.max(stats.maxStreak, stats.currentStreak);
  stats.lastPlayed = today;
  const key = puzzle.words[0].length + 'L';
  if (!stats.bestTimes[key] || elapsed < stats.bestTimes[key]) {
    stats.bestTimes[key] = elapsed;
  }
  saveStats(stats);
  updateStatsLine();

  render();

  setTimeout(() => {
    const hint = hintsUsed > 0 ? ` (${hintsUsed} aiuti usati)` : '';
    document.getElementById('winMsg').textContent =
      `Hai completato la scaletta in ${formatTime(elapsed)}!${hint}`;
    document.getElementById('winModal').classList.add('show');
  }, 500);
}

// --- Input Handling ---
function onKeyDown(e) {
  if (gameWon) return;

  if (e.key === 'Enter') {
    e.preventDefault();
    if (phase === 1) submitClueAnswer();
    else if (phase === 3) submitPhase3Word();
    return;
  }

  if (e.key === 'Backspace') {
    e.preventDefault();
    handleBackspace();
    return;
  }

  if (e.key.length === 1 && /^[a-zA-ZàèéìòùÀÈÉÌÒÙ]$/.test(e.key)) {
    e.preventDefault();
    handleLetter(e.key.toLowerCase());
  }
}

function handleLetter(ch) {
  if (gameWon) return;
  const wordLen = puzzle.words[0].length;

  if (phase === 1) {
    if (activeClueIdx < 0) return;
    if (typingBuffer.length < wordLen) {
      typingBuffer += ch;
      render();
      if (typingBuffer.length === wordLen) {
        setTimeout(() => submitClueAnswer(), 150);
      }
    }
  } else if (phase === 3) {
    if (phase3Focus === 'top') {
      if (topWord.length < wordLen) {
        topWord += ch;
        render();
        if (topWord.length === wordLen) {
          setTimeout(() => submitPhase3Word(), 150);
        }
      }
    } else {
      if (bottomWord.length < wordLen) {
        bottomWord += ch;
        render();
        if (bottomWord.length === wordLen) {
          setTimeout(() => submitPhase3Word(), 150);
        }
      }
    }
  }
}

function handleBackspace() {
  if (phase === 1) {
    if (typingBuffer.length > 0) {
      typingBuffer = typingBuffer.slice(0, -1);
      render();
    }
  } else if (phase === 3) {
    if (phase3Focus === 'top') {
      if (topWord.length > 0) { topWord = topWord.slice(0, -1); render(); }
    } else {
      if (bottomWord.length > 0) { bottomWord = bottomWord.slice(0, -1); render(); }
    }
  }
}

// --- Keyboard (mobile) ---
function buildKeyboard() {
  const rows = [
    ['Q','W','E','R','T','Y','U','I','O','P'],
    ['A','S','D','F','G','H','J','K','L'],
    ['INVIO','Z','X','C','V','B','N','M','⌫']
  ];

  keyboardEl.innerHTML = '';
  for (const row of rows) {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'kb-row';
    for (const key of row) {
      const btn = document.createElement('button');
      btn.className = 'kb-key';
      if (key === '⌫' || key === 'INVIO') {
        btn.classList.add('wide');
        if (key === 'INVIO') btn.classList.add('action');
      }
      btn.textContent = key;
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        if (key === '⌫') handleBackspace();
        else if (key === 'INVIO') {
          if (phase === 1) submitClueAnswer();
          else if (phase === 3) submitPhase3Word();
        } else handleLetter(key.toLowerCase());
      });
      rowDiv.appendChild(btn);
    }
    keyboardEl.appendChild(rowDiv);
  }
}

// --- Hint ---
function useHint() {
  if (gameWon) return;
  hintsUsed++;

  if (phase === 1) {
    // Reveal current clue's answer
    if (activeClueIdx < 0) return;
    const word = puzzle.words[activeClueIdx + 1];
    typingBuffer = word;
    render();
    setTimeout(() => submitClueAnswer(), 300);
  } else if (phase === 2) {
    // Put one word in the correct position
    const correct = puzzle.words.slice(1, -1);
    for (let i = 0; i < middleOrder.length; i++) {
      if (middleOrder[i] !== correct[i]) {
        // Find correct word and swap
        const correctWord = correct[i];
        const j = middleOrder.indexOf(correctWord);
        if (j >= 0) {
          [middleOrder[i], middleOrder[j]] = [middleOrder[j], middleOrder[i]];
          swapSelected = -1;
          render();
          // Check completion
          if (middleOrder.join(',') === correct.join(',')) {
            setTimeout(() => startPhase3(), 400);
          }
          return;
        }
      }
    }
  } else if (phase === 3) {
    if (phase3Focus === 'top') {
      topWord = puzzle.words[0];
      render();
      setTimeout(() => submitPhase3Word(), 300);
    } else {
      bottomWord = puzzle.words[puzzle.words.length - 1];
      render();
      setTimeout(() => submitPhase3Word(), 300);
    }
  }
}

// --- Timer ---
function startTimer() {
  stopTimer();
  startTime = Date.now();
  elapsed = 0;
  timerEl.textContent = '00:00';
  timerInterval = setInterval(() => {
    elapsed = Date.now() - startTime;
    timerEl.textContent = formatTime(elapsed);
  }, 1000);
}

function stopTimer() {
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

function formatTime(ms) {
  const s = Math.floor(ms / 1000);
  const m = Math.floor(s / 60);
  return String(m).padStart(2, '0') + ':' + String(s % 60).padStart(2, '0');
}

// --- Stats ---
function showStats() {
  const stats = loadStats();
  const grid = document.getElementById('statsGrid');
  grid.innerHTML = `
    <div class="stat-item"><div class="num">${stats.gamesPlayed}</div><div class="lbl">Partite</div></div>
    <div class="stat-item"><div class="num">${stats.gamesWon}</div><div class="lbl">Vittorie</div></div>
    <div class="stat-item"><div class="num">${stats.currentStreak}</div><div class="lbl">Serie attuale</div></div>
    <div class="stat-item"><div class="num">${stats.maxStreak}</div><div class="lbl">Serie max</div></div>
  `;
  document.getElementById('statsModal').classList.add('show');
}

function closeModal(id) { document.getElementById(id).classList.remove('show'); }

function updateStatsLine() {
  const s = loadStats();
  if (s.gamesPlayed > 0) {
    statsLineEl.textContent = `Vinte: ${s.gamesWon}/${s.gamesPlayed} · Serie: ${s.currentStreak}`;
  }
}

// --- Start ---
init();
</script>
</body>
</html>
