<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#6C5CE7">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Puzzle">
<link rel="manifest" href="manifest.json">
<link rel="icon" href="icon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="icon.svg">
<title>PathTrace - Puzzle Game</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

  :root {
    --bg: #faf8f5;
    --card: #ffffff;
    --primary: #6C5CE7;
    --primary-light: #e8e4fd;
    --path: #6C5CE7;
    --path-light: #d5d0f5;
    --number-bg: #6C5CE7;
    --number-text: #ffffff;
    --cell-border: #d9d9d9;
    --text: #2d2d2d;
    --text-muted: #777777;
    --success: #00b894;
    --cell-size: 60px;
    --gap: 2px;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    -webkit-user-select: none;
  }

  header {
    width: 100%;
    max-width: 500px;
    padding: 16px 20px 8px;
    text-align: center;
    position: relative;
  }

  header h1 {
    font-size: 28px;
    font-weight: 700;
    letter-spacing: 2px;
    color: var(--primary);
    text-transform: uppercase;
  }

  header p {
    font-size: 13px;
    color: var(--text-muted);
    margin-top: 2px;
  }

  .toolbar {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 8px 20px;
    width: 100%;
    max-width: 500px;
  }

  .timer {
    font-size: 22px;
    font-weight: 600;
    font-variant-numeric: tabular-nums;
    color: var(--text);
    min-width: 70px;
    text-align: center;
  }

  .btn {
    border: none;
    border-radius: 20px;
    padding: 8px 18px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }

  .btn:active { transform: scale(0.95); }

  .btn-outline {
    background: transparent;
    color: var(--primary);
    border: 2px solid var(--primary);
  }

  .btn-outline:hover { background: var(--primary-light); }

  .btn-primary {
    background: var(--primary);
    color: #fff;
  }

  .btn-primary:hover { background: #5a4bd6; }

  .diff-selector {
    display: flex;
    gap: 8px;
    padding: 4px 20px 12px;
    justify-content: center;
    flex-wrap: wrap;
    max-width: 500px;
  }

  .diff-btn {
    border-radius: 20px;
    border: 2px solid #d9d9d9;
    background: var(--card);
    padding: 6px 16px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--text);
  }

  .diff-btn.active {
    background: var(--primary);
    color: #fff;
    border-color: var(--primary);
  }

  .diff-btn:hover:not(.active) { background: var(--primary-light); }

  .stats {
    font-size: 12px;
    color: var(--text-muted);
    text-align: center;
    padding: 0 20px 8px;
  }

  .board-container {
    background: var(--card);
    border-radius: 16px;
    padding: 16px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.08);
    position: relative;
    touch-action: none;
  }

  .board {
    display: grid;
    gap: var(--gap);
    position: relative;
    background: #f0f0f0;
    border-radius: 8px;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    background: #f8f8f8;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 700;
    position: relative;
    transition: background 0.15s;
    cursor: pointer;
  }

  .cell.numbered {
    color: var(--number-text);
  }

  .cell.numbered .cell-number {
    width: 36px;
    height: 36px;
    background: var(--number-bg);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: 700;
    position: relative;
    z-index: 4;
  }

  .cell.visited {
    background: transparent;
  }

  .cell.visited .cell-number {
    background: #5a4bd6;
  }

  .cell.current {
    background: transparent;
  }

  .cell.current .cell-number {
    background: #fff;
    color: var(--primary);
    box-shadow: 0 0 0 3px var(--primary);
    z-index: 5;
  }

  .cell.current:not(.numbered)::after {
    content: '';
    width: 20px;
    height: 20px;
    background: #fff;
    border-radius: 50%;
    position: absolute;
    z-index: 5;
    box-shadow: 0 0 0 3px var(--primary);
  }

  svg.connections {
    position: absolute;
    top: 16px;
    left: 16px;
    pointer-events: none;
    z-index: 2;
  }

  .message {
    margin-top: 16px;
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    text-align: center;
    opacity: 0;
    transition: opacity 0.3s;
  }

  .message.visible {
    opacity: 1;
  }

  .message.success {
    background: #e8f5e9;
    color: var(--success);
  }

  .message.error {
    background: #fce4ec;
    color: #c62828;
  }

  .overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }

  .overlay.visible { display: flex; }

  .modal {
    background: var(--card);
    border-radius: 20px;
    padding: 32px;
    max-width: 340px;
    width: 90%;
    text-align: center;
    animation: pop 0.3s ease;
  }

  @keyframes pop {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 { font-size: 24px; margin-bottom: 8px; color: var(--success); }
  .modal p { color: var(--text-muted); margin-bottom: 20px; }
  .modal .time { font-size: 36px; font-weight: 700; color: var(--text); margin: 8px 0; }

  .instructions {
    max-width: 500px;
    padding: 12px 20px;
    text-align: center;
    font-size: 13px;
    color: var(--text-muted);
    line-height: 1.5;
  }

  .cell.start-hint .cell-number {
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(108,92,231,0.4); }
    50% { transform: scale(1.15); box-shadow: 0 0 0 8px rgba(108,92,231,0); }
  }

  @media (max-width: 420px) {
    :root { --cell-size: 50px; }
    .cell .cell-number { width: 30px; height: 30px; font-size: 14px; }
  }

  @media (max-width: 350px) {
    :root { --cell-size: 44px; }
  }
</style>
</head>
<body>

<header>
  <a href="index.html" style="position:absolute;left:16px;top:16px;color:var(--primary);text-decoration:none;font-size:18px;font-weight:600;">← Menu</a>
  <h1>PathTrace</h1>
  <p>Traccia il percorso attraverso ogni cella</p>
</header>

<div class="toolbar">
  <button class="btn btn-outline" id="btnUndo">↩ Annulla</button>
  <div class="timer" id="timer">0:00</div>
  <button class="btn btn-outline" id="btnReset">⟳ Reset</button>
</div>

<div class="diff-selector" id="diffSelector">
  <button class="diff-btn active" data-size="5">5×5</button>
  <button class="diff-btn" data-size="6">6×6</button>
  <button class="diff-btn" data-size="7">7×7</button>
  <button class="diff-btn" data-size="8">8×8</button>
  <button class="diff-btn" data-size="9">9×9</button>
</div>

<p class="stats" id="stats"></p>

<div class="board-container" id="boardContainer">
  <svg class="connections" id="svgConnections"></svg>
  <div class="board" id="board"></div>
</div>

<div class="message" id="message"></div>

<p class="instructions">
  Parti dal numero <strong>1</strong> e traccia un percorso continuo che passi per ogni cella,
  toccando i numeri in ordine crescente. Muoviti in orizzontale o verticale.
</p>

<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="modalTitle">Completato!</h2>
    <div class="time" id="modalTime">0:00</div>
    <p id="modalMsg">Hai risolto il puzzle!</p>
    <button class="btn btn-primary" id="btnNext" style="margin-top:8px;">Nuovo puzzle →</button>
  </div>
</div>

<script>
// ─── Seeded PRNG (Mulberry32) ───────────────────────────────────
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ─── Hamiltonian Path Generator (Warnsdorff's heuristic) ────────
function generateHamiltonianPath(rows, cols, rng) {
  const total = rows * cols;

  function neighbors(idx) {
    const r = Math.floor(idx / cols), c = idx % cols;
    const ns = [];
    if (r > 0) ns.push(idx - cols);
    if (r < rows - 1) ns.push(idx + cols);
    if (c > 0) ns.push(idx - 1);
    if (c < cols - 1) ns.push(idx + 1);
    return ns;
  }

  function tryPath(startIdx) {
    const visited = new Uint8Array(total);
    const path = [startIdx];
    visited[startIdx] = 1;

    while (path.length < total) {
      const curr = path[path.length - 1];
      const nexts = neighbors(curr).filter(n => !visited[n]);
      if (nexts.length === 0) break;

      nexts.sort((a, b) => {
        const da = neighbors(a).filter(n => !visited[n]).length;
        const db = neighbors(b).filter(n => !visited[n]).length;
        return da - db || (rng() - 0.5);
      });
      const next = nexts[0];
      visited[next] = 1;
      path.push(next);
    }
    return path;
  }

  for (let attempt = 0; attempt < 50; attempt++) {
    const start = Math.floor(rng() * total);
    const path = tryPath(start);
    if (path.length === total) return path;
  }

  for (const start of [0, cols - 1, (rows - 1) * cols, total - 1]) {
    const path = tryPath(start);
    if (path.length === total) return path;
  }

  return null;
}

// ─── Waypoints config per size ──────────────────────────────────
function getWaypointsForSize(size, rng) {
  const configs = {
    5: [3, 4, 5],
    6: [4, 5, 6],
    7: [5, 6, 7],
    8: [6, 7, 8],
    9: [7, 8, 9],
  };
  const options = configs[size] || [4, 5, 6];
  return options[Math.floor(rng() * options.length)];
}

// ─── Puzzle Generator ───────────────────────────────────────────
function generatePuzzle(rows, cols, numWaypoints, seed) {
  const rng = mulberry32(seed);
  const solutionPath = generateHamiltonianPath(rows, cols, rng);
  if (!solutionPath) return null;

  const total = rows * cols;
  const numbers = {};

  const positions = [0];
  const innerCount = numWaypoints - 2;
  for (let i = 1; i <= innerCount; i++) {
    const pos = Math.round((i / (numWaypoints - 1)) * (total - 1));
    positions.push(pos);
  }
  positions.push(total - 1);

  positions.forEach((pos, i) => {
    numbers[solutionPath[pos]] = i + 1;
  });

  return { rows, cols, numbers, _solution: solutionPath };
}

function generateRandomPuzzle(size) {
  let seed = (Date.now() ^ (Math.random() * 0xFFFF)) & 0xFFFFFF;
  const rng = mulberry32(seed);
  const waypoints = getWaypointsForSize(size, rng);
  let puzzle = null;
  let attempts = 0;
  while (!puzzle && attempts < 200) {
    puzzle = generatePuzzle(size, size, waypoints, seed);
    seed += 7;
    attempts++;
  }
  return puzzle;
}

// ─── Persistence (localStorage) ─────────────────────────────────
const STORAGE_KEY = 'pathtrace_stats';
function loadStats() {
  try {
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
    if (data) return data;
  } catch(e) {}
  return { gamesWon: {5:0,6:0,7:0,8:0,9:0}, bestTimes: {5:null,6:null,7:null,8:null,9:null} };
}
function saveStats() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(stats));
}
let stats = loadStats();

// ─── Game State ─────────────────────────────────────────────────
let currentSize = 5;
let path = [];
let totalCells = 0;
let puzzle = null;
let timerInterval = null;
let startTime = 0;
let elapsed = 0;
let timerRunning = false;
let solved = false;
let isDrawing = false;

// ─── DOM refs ───────────────────────────────────────────────────
const boardEl = document.getElementById('board');
const svgEl = document.getElementById('svgConnections');
const timerEl = document.getElementById('timer');
const messageEl = document.getElementById('message');
const overlayEl = document.getElementById('overlay');
const boardContainer = document.getElementById('boardContainer');
const statsEl = document.getElementById('stats');

// ─── Difficulty Selector ────────────────────────────────────────
const diffBtns = document.querySelectorAll('.diff-btn');
diffBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const size = parseInt(btn.dataset.size);
    currentSize = size;
    diffBtns.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    newGame();
  });
});

function updateStats() {
  const won = stats.gamesWon[currentSize] || 0;
  const best = stats.bestTimes[currentSize];
  let text = `${currentSize}\u00D7${currentSize} \u2014 Vinti: ${won}`;
  if (best) text += ` \u00B7 Record: ${formatTime(best)}`;
  statsEl.textContent = text;
}

// ─── New Game ───────────────────────────────────────────────────
function newGame() {
  puzzle = generateRandomPuzzle(currentSize);
  if (!puzzle) {
    showMessage('Errore nel generare il puzzle', 'error');
    return;
  }

  const maxGridPx = Math.min(window.innerWidth - 64, 420);
  const idealSize = Math.floor((maxGridPx - (puzzle.cols - 1) * 2) / puzzle.cols);
  const cellSize = Math.min(60, Math.max(36, idealSize));
  document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
  totalCells = puzzle.rows * puzzle.cols;
  path = [];
  solved = false;
  elapsed = 0;
  stopTimer();
  timerEl.textContent = '0:00';
  hideMessage();
  overlayEl.classList.remove('visible');
  updateStats();
  renderBoard();
}

// ─── Render Board ───────────────────────────────────────────────
function renderBoard() {
  const { rows, cols, numbers } = puzzle;
  boardEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
  boardEl.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
  boardEl.innerHTML = '';

  const cellSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
  const gapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
  const totalW = cols * cellSizePx + (cols - 1) * gapPx;
  const totalH = rows * cellSizePx + (rows - 1) * gapPx;
  svgEl.setAttribute('width', totalW);
  svgEl.setAttribute('height', totalH);
  svgEl.innerHTML = '';

  for (let i = 0; i < totalCells; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.index = i;

    if (numbers[i] !== undefined) {
      cell.classList.add('numbered');
      const numEl = document.createElement('div');
      numEl.className = 'cell-number';
      numEl.textContent = numbers[i];
      cell.appendChild(numEl);
    }

    boardEl.appendChild(cell);
  }
}

// Pointer events
boardContainer.addEventListener('pointerdown', onPointerDown);
boardContainer.addEventListener('pointermove', onPointerMove);
boardContainer.addEventListener('pointerup', onPointerUp);
boardContainer.addEventListener('pointerleave', onPointerUp);

function getCellFromPoint(x, y) {
  const el = document.elementFromPoint(x, y);
  if (!el) return -1;
  const cell = el.closest('.cell');
  if (!cell) return -1;
  return parseInt(cell.dataset.index);
}

// ─── Pointer Handling ───────────────────────────────────────────
function onPointerDown(e) {
  if (solved) return;
  e.preventDefault();
  const idx = getCellFromPoint(e.clientX, e.clientY);
  if (idx < 0) return;

  if (path.length === 0) {
    const startCell = Object.entries(puzzle.numbers).find(([_, n]) => n === 1);
    if (startCell && parseInt(startCell[0]) === idx) {
      path = [idx];
      isDrawing = true;
      startTimer();
      updateVisuals();
    }
  } else if (idx === path[path.length - 1]) {
    isDrawing = true;
  } else if (path.includes(idx)) {
    const pathIdx = path.indexOf(idx);
    path = path.slice(0, pathIdx + 1);
    isDrawing = true;
    updateVisuals();
  }
}

function onPointerMove(e) {
  if (!isDrawing || solved) return;
  e.preventDefault();
  const idx = getCellFromPoint(e.clientX, e.clientY);
  if (idx < 0) return;
  tryMove(idx);
}

function onPointerUp(e) {
  isDrawing = false;
  if (solved) return;
  checkWin();
}

function tryMove(idx) {
  if (path.length === 0) return;

  const current = path[path.length - 1];
  if (idx === current) return;

  if (path.length >= 2 && idx === path[path.length - 2]) {
    path.pop();
    updateVisuals();
    return;
  }

  if (!isAdjacent(current, idx)) return;
  if (path.includes(idx)) return;

  if (puzzle.numbers[idx] !== undefined) {
    const num = puzzle.numbers[idx];
    const nextExpected = getNextExpectedNumber();
    if (num !== nextExpected) return;
  }

  path.push(idx);
  updateVisuals();

  if (path.length === totalCells) {
    checkWin();
  }
}

function isAdjacent(a, b) {
  const cols = puzzle.cols;
  const rowA = Math.floor(a / cols), colA = a % cols;
  const rowB = Math.floor(b / cols), colB = b % cols;
  return (Math.abs(rowA - rowB) + Math.abs(colA - colB)) === 1;
}

function getNextExpectedNumber() {
  const visited = new Set(path);
  const sortedNumbers = Object.entries(puzzle.numbers)
    .map(([idx, num]) => ({ idx: parseInt(idx), num }))
    .sort((a, b) => a.num - b.num);

  for (const { idx, num } of sortedNumbers) {
    if (!visited.has(idx)) return num;
  }
  return Infinity;
}

// ─── Undo ───────────────────────────────────────────────────────
function undo() {
  if (path.length <= 1 || solved) return;
  path.pop();
  updateVisuals();
}

// ─── Update Visuals ─────────────────────────────────────────────
function updateVisuals() {
  const cells = boardEl.querySelectorAll('.cell');
  const visited = new Set(path);
  const currentIdx = path.length > 0 ? path[path.length - 1] : -1;

  const startCellIdx = parseInt(Object.entries(puzzle.numbers).find(([_, n]) => n === 1)?.[0] ?? -1);

  cells.forEach(cell => {
    const idx = parseInt(cell.dataset.index);
    cell.classList.toggle('visited', visited.has(idx) && idx !== currentIdx);
    cell.classList.toggle('current', idx === currentIdx);
    cell.classList.toggle('start-hint', path.length === 0 && idx === startCellIdx);
  });

  const cellSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
  const gapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
  svgEl.innerHTML = '';

  if (path.length >= 2) {
    const points = path.map(idx => {
      const x = (idx % puzzle.cols) * (cellSizePx + gapPx) + cellSizePx / 2;
      const y = Math.floor(idx / puzzle.cols) * (cellSizePx + gapPx) + cellSizePx / 2;
      return `${x},${y}`;
    }).join(' ');

    const mainLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    mainLine.setAttribute('points', points);
    mainLine.setAttribute('fill', 'none');
    mainLine.setAttribute('stroke', '#6C5CE7');
    mainLine.setAttribute('stroke-width', String(cellSizePx * 0.65));
    mainLine.setAttribute('stroke-linejoin', 'round');
    mainLine.setAttribute('stroke-linecap', 'round');
    svgEl.appendChild(mainLine);
  }
}

// ─── Win Check ──────────────────────────────────────────────────
function checkWin() {
  if (path.length !== totalCells) return;

  const numberEntries = Object.entries(puzzle.numbers)
    .map(([idx, num]) => ({ idx: parseInt(idx), num }))
    .sort((a, b) => a.num - b.num);

  let lastPos = -1;
  for (const { idx } of numberEntries) {
    const pos = path.indexOf(idx);
    if (pos <= lastPos) return;
    lastPos = pos;
  }

  // WIN!
  solved = true;
  stopTimer();

  stats.gamesWon[currentSize] = (stats.gamesWon[currentSize] || 0) + 1;
  if (!stats.bestTimes[currentSize] || elapsed < stats.bestTimes[currentSize]) {
    stats.bestTimes[currentSize] = elapsed;
  }
  saveStats();
  updateStats();

  showMessage('Complimenti! Puzzle risolto!', 'success');

  const isNewBest = elapsed === stats.bestTimes[currentSize];
  setTimeout(() => {
    document.getElementById('modalTime').textContent = formatTime(elapsed);
    document.getElementById('modalMsg').textContent = `${currentSize}\u00D7${currentSize} completato!` + (isNewBest ? ' Nuovo record!' : '');
    overlayEl.classList.add('visible');
  }, 600);
}

// ─── Timer ──────────────────────────────────────────────────────
function startTimer() {
  if (timerRunning) return;
  timerRunning = true;
  startTime = Date.now() - elapsed;
  timerInterval = setInterval(() => {
    elapsed = Date.now() - startTime;
    timerEl.textContent = formatTime(elapsed);
  }, 100);
}

function stopTimer() {
  timerRunning = false;
  clearInterval(timerInterval);
}

function formatTime(ms) {
  const totalSec = Math.floor(ms / 1000);
  const min = Math.floor(totalSec / 60);
  const sec = totalSec % 60;
  return `${min}:${sec.toString().padStart(2, '0')}`;
}

// ─── Messages ───────────────────────────────────────────────────
function showMessage(text, type) {
  messageEl.textContent = text;
  messageEl.className = 'message visible ' + type;
  setTimeout(() => hideMessage(), 3000);
}

function hideMessage() {
  messageEl.classList.remove('visible');
}

// ─── Button handlers ────────────────────────────────────────────
document.getElementById('btnUndo').addEventListener('click', undo);
document.getElementById('btnReset').addEventListener('click', () => newGame());
document.getElementById('btnNext').addEventListener('click', () => newGame());

// Keyboard support
document.addEventListener('keydown', (e) => {
  if (solved) return;

  if (path.length === 0) {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
      const startCell = Object.entries(puzzle.numbers).find(([_, n]) => n === 1);
      if (startCell) {
        path = [parseInt(startCell[0])];
        startTimer();
        updateVisuals();
      }
    }
    return;
  }
  const current = path[path.length - 1];
  const cols = puzzle.cols;
  let target = -1;

  switch (e.key) {
    case 'ArrowUp':    target = current - cols; break;
    case 'ArrowDown':  target = current + cols; break;
    case 'ArrowLeft':  if (current % cols > 0) target = current - 1; break;
    case 'ArrowRight': if ((current + 1) % cols > 0) target = current + 1; break;
  }

  if (target >= 0 && target < totalCells) {
    e.preventDefault();
    if (!timerRunning) startTimer();

    if (path.length >= 2 && target === path[path.length - 2]) {
      path.pop();
      updateVisuals();
    } else {
      tryMove(target);
    }
  }

  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    undo();
  }
});

// ─── Init ───────────────────────────────────────────────────────
newGame();
</script>
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(regs => {
    Promise.all(regs.map(r => r.unregister())).then(() => {
      navigator.serviceWorker.register('sw.js');
    });
  });
}
</script>
</body>
</html>
